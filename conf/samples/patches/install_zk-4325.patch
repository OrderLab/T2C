diff --git a/bin/zkEnv.sh b/bin/zkEnv.sh
index 8d93a50c7..3f970e1f9 100755
--- a/bin/zkEnv.sh
+++ b/bin/zkEnv.sh
@@ -127,6 +127,9 @@ CLASSPATH="$ZOOBINDIR/../build/classes:$CLASSPATH"
 #make it work for developers
 CLASSPATH="$ZOOBINDIR/../zookeeper-server/target/classes:$CLASSPATH"
 
+#CHANG: load testing classes at runtime
+CLASSPATH="$ZOOBINDIR/../build/test/classes:$CLASSPATH"
+
 case "`uname`" in
     CYGWIN*|MINGW*) cygwin=true ;;
     *) cygwin=false ;;
diff --git a/bin/zkServer.sh b/bin/zkServer.sh
index 4780118ab..f027ea717 100755
--- a/bin/zkServer.sh
+++ b/bin/zkServer.sh
@@ -33,6 +33,7 @@ else
   . "$ZOOBINDIR"/zkEnv.sh
 fi
 
+JMXDISABLE="true"
 # See the following page for extensive details on setting
 # up the JVM to accept JMX remote management:
 # http://java.sun.com/javase/6/docs/technotes/guides/management/agent.html
@@ -155,10 +156,11 @@ start)
          exit 1
       fi
     fi
+    T2CFLAGS="-Dt2c.mode=prod -Dconf=CONF_PATH_MACRO -Dt2c.t2c_root_abs_path=T2C_DIR_MACRO -Dt2c.target_system_abs_path=SYS_DIR_MACRO"
     nohup "$JAVA" $ZOO_DATADIR_AUTOCREATE "-Dzookeeper.log.dir=${ZOO_LOG_DIR}" \
     "-Dzookeeper.log.file=${ZOO_LOG_FILE}" "-Dzookeeper.root.logger=${ZOO_LOG4J_PROP}" \
     -XX:+HeapDumpOnOutOfMemoryError -XX:OnOutOfMemoryError='kill -9 %p' \
-    -cp "$CLASSPATH" $JVMFLAGS $ZOOMAIN "$ZOOCFG" > "$_ZOO_DAEMON_OUT" 2>&1 < /dev/null &
+    -cp "$CLASSPATH" $JVMFLAGS $T2CFLAGS edu.jhu.order.t2c.dynamicd.runtime.MainWrapper $ZOOMAIN "$ZOOCFG" > "$_ZOO_DAEMON_OUT" 2>&1 < /dev/null &
     if [ $? -eq 0 ]
     then
       case "$OSTYPE" in
diff --git a/zookeeper-server/pom.xml b/zookeeper-server/pom.xml
index d69e7c63d..780ac49bc 100755
--- a/zookeeper-server/pom.xml
+++ b/zookeeper-server/pom.xml
@@ -162,6 +162,13 @@
       <artifactId>snappy-java</artifactId>
       <scope>provided</scope>
     </dependency>
+    <dependency>
+      <groupId>edu.jhu.order.t2c</groupId>
+      <artifactId>t2c</artifactId>
+      <version>1.0</version>
+      <scope>system</scope>
+      <systemPath>T2C_DIR_MACRO/target/t2c-1.0-SNAPSHOT-jar-with-dependencies.jar</systemPath>
+    </dependency>
   </dependencies>
 
   <build>
diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/ZooDefs.java b/zookeeper-server/src/main/java/org/apache/zookeeper/ZooDefs.java
index a12e5803c..f7a96054d 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/ZooDefs.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/ZooDefs.java
@@ -24,6 +24,7 @@
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.zookeeper.data.ACL;
 import org.apache.zookeeper.data.Id;
+import edu.jhu.order.t2c.dynamicd.runtime.MarkedOp;
 
 @InterfaceAudience.Public
 public class ZooDefs {
@@ -35,67 +36,67 @@ public class ZooDefs {
     @InterfaceAudience.Public
     public interface OpCode {
 
-        int notification = 0;
+        @MarkedOp int notification = 0;
 
-        int create = 1;
+        @MarkedOp int create = 1;
 
-        int delete = 2;
+        @MarkedOp int delete = 2;
 
-        int exists = 3;
+        @MarkedOp int exists = 3;
 
-        int getData = 4;
+        @MarkedOp int getData = 4;
 
-        int setData = 5;
+        @MarkedOp int setData = 5;
 
-        int getACL = 6;
+        @MarkedOp int getACL = 6;
 
-        int setACL = 7;
+        @MarkedOp int setACL = 7;
 
-        int getChildren = 8;
+        @MarkedOp int getChildren = 8;
 
-        int sync = 9;
+        @MarkedOp int sync = 9;
 
-        int ping = 11;
+        @MarkedOp int ping = 11;
 
-        int getChildren2 = 12;
+        @MarkedOp int getChildren2 = 12;
 
-        int check = 13;
+        @MarkedOp int check = 13;
 
-        int multi = 14;
+        @MarkedOp int multi = 14;
 
-        int create2 = 15;
+        @MarkedOp int create2 = 15;
 
-        int reconfig = 16;
+        @MarkedOp int reconfig = 16;
 
-        int checkWatches = 17;
+        @MarkedOp int checkWatches = 17;
 
-        int removeWatches = 18;
+        @MarkedOp int removeWatches = 18;
 
-        int createContainer = 19;
+        @MarkedOp int createContainer = 19;
 
-        int deleteContainer = 20;
+        @MarkedOp int deleteContainer = 20;
 
-        int createTTL = 21;
+        @MarkedOp int createTTL = 21;
 
-        int multiRead = 22;
+        @MarkedOp int multiRead = 22;
 
-        int auth = 100;
+        @MarkedOp int auth = 100;
 
-        int setWatches = 101;
+        @MarkedOp int setWatches = 101;
 
-        int sasl = 102;
+        @MarkedOp int sasl = 102;
 
-        int getEphemerals = 103;
+        @MarkedOp int getEphemerals = 103;
 
-        int getAllChildrenNumber = 104;
+        @MarkedOp int getAllChildrenNumber = 104;
 
-        int setWatches2 = 105;
+        @MarkedOp int setWatches2 = 105;
 
-        int addWatch = 106;
+        @MarkedOp int addWatch = 106;
 
-        int createSession = -10;
+        @MarkedOp int createSession = -10;
 
-        int closeSession = -11;
+        @MarkedOp int closeSession = -11;
 
         int error = -1;
 
diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/FinalRequestProcessor.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/FinalRequestProcessor.java
index 9ffde55c1..164a91f72 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/FinalRequestProcessor.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/FinalRequestProcessor.java
@@ -18,6 +18,7 @@
 
 package org.apache.zookeeper.server;
 
+import edu.jhu.order.t2c.dynamicd.runtime.MarkedOpFunc;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
@@ -106,6 +107,21 @@ public FinalRequestProcessor(ZooKeeperServer zks) {
         this.requestPathMetricsCollector = zks.getRequestPathMetricsCollector();
     }
 
+    @MarkedOpFunc("exists")
+    Record existsRequest(Request request, ServerCnxn cnxn) throws IOException, KeeperException {
+        // TODO we need to figure out the security requirement for this!
+        ExistsRequest existsRequest = new ExistsRequest();
+        ByteBufferInputStream.byteBuffer2Record(request.request, existsRequest);
+        String path = existsRequest.getPath();
+        if (path.indexOf('\0') != -1) {
+            throw new KeeperException.BadArgumentsException();
+        }
+        Stat stat = zks.getZKDatabase().statNode(path, existsRequest.getWatch() ? cnxn : null);
+        Record rsp = new ExistsResponse(stat);
+        requestPathMetricsCollector.registerRequest(request.type, path);
+        return rsp;
+    }
+
     public void processRequest(Request request) {
         LOG.debug("Processing request:: {}", request);
 
@@ -348,16 +364,7 @@ public void processRequest(Request request) {
             }
             case OpCode.exists: {
                 lastOp = "EXIS";
-                // TODO we need to figure out the security requirement for this!
-                ExistsRequest existsRequest = new ExistsRequest();
-                ByteBufferInputStream.byteBuffer2Record(request.request, existsRequest);
-                path = existsRequest.getPath();
-                if (path.indexOf('\0') != -1) {
-                    throw new KeeperException.BadArgumentsException();
-                }
-                Stat stat = zks.getZKDatabase().statNode(path, existsRequest.getWatch() ? cnxn : null);
-                rsp = new ExistsResponse(stat);
-                requestPathMetricsCollector.registerRequest(request.type, path);
+                rsp = existsRequest(request, cnxn);
                 break;
             }
             case OpCode.getData: {
diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java
index 399f94881..d80867578 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -18,6 +18,7 @@
 
 package org.apache.zookeeper.server;
 
+import edu.jhu.order.t2c.dynamicd.runtime.Operation;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.StringReader;
@@ -81,6 +82,7 @@
 import org.apache.zookeeper.txn.TxnHeader;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
+import edu.jhu.order.t2c.dynamicd.runtime.MarkedOpFunc;
 
 /**
  * This request processor is generally at the start of a RequestProcessor
@@ -306,337 +308,414 @@ private String validatePathForCreate(String path, long sessionId) throws BadArgu
         return path.substring(0, lastSlash);
     }
 
-    /**
-     * This method will be called inside the ProcessRequestThread, which is a
-     * singleton, so there will be a single thread calling this code.
-     *
-     * @param type
-     * @param zxid
-     * @param request
-     * @param record
-     */
-    protected void pRequest2Txn(int type, long zxid, Request request, Record record, boolean deserialize) throws KeeperException, IOException, RequestProcessorException {
-        if (request.getHdr() == null) {
-            request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid,
-                    Time.currentWallTime(), type));
-        }
+    @MarkedOpFunc("create")
+    void createRequest(int type, Request request, Record record, boolean deserialize)
+            throws KeeperException, IOException, RequestProcessorException {
+        pRequest2TxnCreate(type, request, record, deserialize);
+    }
 
-        PrecalculatedDigest precalculatedDigest;
-        switch (type) {
-        case OpCode.create:
-        case OpCode.create2:
-        case OpCode.createTTL:
-        case OpCode.createContainer: {
-            pRequest2TxnCreate(type, request, record, deserialize);
-            break;
+    @MarkedOpFunc("create2")
+    void create2Request(int type, Request request, Record record, boolean deserialize)
+            throws KeeperException, IOException, RequestProcessorException {
+        pRequest2TxnCreate(type, request, record, deserialize);
+    }
+
+    @MarkedOpFunc("createTTL")
+    void createTTLRequest(int type, Request request, Record record, boolean deserialize)
+            throws KeeperException, IOException, RequestProcessorException {
+        pRequest2TxnCreate(type, request, record, deserialize);
+    }
+
+    @MarkedOpFunc("createContainer")
+    void createContainerRequest(int type, Request request, Record record, boolean deserialize)
+            throws KeeperException, IOException, RequestProcessorException {
+        pRequest2TxnCreate(type, request, record, deserialize);
+    }
+
+    @MarkedOpFunc("deleteContainer")
+    void deleteContainerRequest(Request request,  Record record, boolean deserialize) throws KeeperException, IOException, RequestProcessorException
+    {
+        String path = new String(request.request.array());
+        String parentPath = getParentPathAndValidate(path);
+        ChangeRecord nodeRecord = getRecordForPath(path);
+        if (nodeRecord.childCount > 0) {
+            throw new KeeperException.NotEmptyException(path);
         }
-        case OpCode.deleteContainer: {
-            String path = new String(request.request.array());
-            String parentPath = getParentPathAndValidate(path);
-            ChangeRecord nodeRecord = getRecordForPath(path);
-            if (nodeRecord.childCount > 0) {
-                throw new KeeperException.NotEmptyException(path);
-            }
-            if (EphemeralType.get(nodeRecord.stat.getEphemeralOwner()) == EphemeralType.NORMAL) {
-                throw new KeeperException.BadVersionException(path);
-            }
-            ChangeRecord parentRecord = getRecordForPath(parentPath);
-            request.setTxn(new DeleteTxn(path));
-            parentRecord = parentRecord.duplicate(request.getHdr().getZxid());
-            parentRecord.childCount--;
-            parentRecord.stat.setPzxid(request.getHdr().getZxid());
-            parentRecord.precalculatedDigest = precalculateDigest(
-                    DigestOpCode.UPDATE, parentPath, parentRecord.data, parentRecord.stat);
-            addChangeRecord(parentRecord);
-
-            nodeRecord = new ChangeRecord(request.getHdr().getZxid(), path, null, -1, null);
-            nodeRecord.precalculatedDigest = precalculateDigest(DigestOpCode.REMOVE, path);
-            setTxnDigest(request, nodeRecord.precalculatedDigest);
-            addChangeRecord(nodeRecord);
-            break;
+        if (EphemeralType.get(nodeRecord.stat.getEphemeralOwner()) == EphemeralType.NORMAL) {
+            throw new KeeperException.BadVersionException(path);
         }
-        case OpCode.delete:
-            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
-            DeleteRequest deleteRequest = (DeleteRequest) record;
-            if (deserialize) {
-                ByteBufferInputStream.byteBuffer2Record(request.request, deleteRequest);
-            }
-            String path = deleteRequest.getPath();
-            String parentPath = getParentPathAndValidate(path);
-            ChangeRecord parentRecord = getRecordForPath(parentPath);
-            zks.checkACL(request.cnxn, parentRecord.acl, ZooDefs.Perms.DELETE, request.authInfo, path, null);
-            ChangeRecord nodeRecord = getRecordForPath(path);
-            checkAndIncVersion(nodeRecord.stat.getVersion(), deleteRequest.getVersion(), path);
-            if (nodeRecord.childCount > 0) {
-                throw new KeeperException.NotEmptyException(path);
-            }
-            request.setTxn(new DeleteTxn(path));
-            parentRecord = parentRecord.duplicate(request.getHdr().getZxid());
-            parentRecord.childCount--;
-            parentRecord.stat.setPzxid(request.getHdr().getZxid());
-            parentRecord.precalculatedDigest = precalculateDigest(
-                    DigestOpCode.UPDATE, parentPath, parentRecord.data, parentRecord.stat);
-            addChangeRecord(parentRecord);
-
-            nodeRecord = new ChangeRecord(request.getHdr().getZxid(), path, null, -1, null);
-            nodeRecord.precalculatedDigest = precalculateDigest(DigestOpCode.REMOVE, path);
-            setTxnDigest(request, nodeRecord.precalculatedDigest);
-            addChangeRecord(nodeRecord);
-            break;
-        case OpCode.setData:
-            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
-            SetDataRequest setDataRequest = (SetDataRequest) record;
-            if (deserialize) {
-                ByteBufferInputStream.byteBuffer2Record(request.request, setDataRequest);
-            }
-            path = setDataRequest.getPath();
-            validatePath(path, request.sessionId);
-            nodeRecord = getRecordForPath(path);
-            zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.WRITE, request.authInfo, path, null);
-            int newVersion = checkAndIncVersion(nodeRecord.stat.getVersion(), setDataRequest.getVersion(), path);
-            request.setTxn(new SetDataTxn(path, setDataRequest.getData(), newVersion));
-            nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());
-            nodeRecord.stat.setVersion(newVersion);
-            nodeRecord.stat.setMtime(request.getHdr().getTime());
-            nodeRecord.stat.setMzxid(zxid);
-            nodeRecord.data = setDataRequest.getData();
-            nodeRecord.precalculatedDigest = precalculateDigest(
-                    DigestOpCode.UPDATE, path, nodeRecord.data, nodeRecord.stat);
-            setTxnDigest(request, nodeRecord.precalculatedDigest);
-            addChangeRecord(nodeRecord);
-            break;
-        case OpCode.reconfig:
-            if (!zks.isReconfigEnabled()) {
-                LOG.error("Reconfig operation requested but reconfig feature is disabled.");
-                throw new KeeperException.ReconfigDisabledException();
-            }
+        ChangeRecord parentRecord = getRecordForPath(parentPath);
+        request.setTxn(new DeleteTxn(path));
+        parentRecord = parentRecord.duplicate(request.getHdr().getZxid());
+        parentRecord.childCount--;
+        parentRecord.stat.setPzxid(request.getHdr().getZxid());
+        parentRecord.precalculatedDigest = precalculateDigest(
+                DigestOpCode.UPDATE, parentPath, parentRecord.data, parentRecord.stat);
+        addChangeRecord(parentRecord);
 
-            if (ZooKeeperServer.skipACL) {
-                LOG.warn("skipACL is set, reconfig operation will skip ACL checks!");
-            }
+        nodeRecord = new ChangeRecord(request.getHdr().getZxid(), path, null, -1, null);
+        nodeRecord.precalculatedDigest = precalculateDigest(DigestOpCode.REMOVE, path);
+        setTxnDigest(request, nodeRecord.precalculatedDigest);
+        addChangeRecord(nodeRecord);
+    }
 
-            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
-            LeaderZooKeeperServer lzks;
-            try {
-                lzks = (LeaderZooKeeperServer) zks;
-            } catch (ClassCastException e) {
-                // standalone mode - reconfiguration currently not supported
-                throw new KeeperException.UnimplementedException();
-            }
-            QuorumVerifier lastSeenQV = lzks.self.getLastSeenQuorumVerifier();
-            // check that there's no reconfig in progress
-            if (lastSeenQV.getVersion() != lzks.self.getQuorumVerifier().getVersion()) {
-                throw new KeeperException.ReconfigInProgress();
-            }
-            ReconfigRequest reconfigRequest = (ReconfigRequest) record;
-            long configId = reconfigRequest.getCurConfigId();
-
-            if (configId != -1 && configId != lzks.self.getLastSeenQuorumVerifier().getVersion()) {
-                String msg = "Reconfiguration from version "
-                             + configId
-                             + " failed -- last seen version is "
-                             + lzks.self.getLastSeenQuorumVerifier().getVersion();
-                throw new KeeperException.BadVersionException(msg);
-            }
+    @MarkedOpFunc("delete")
+    void deleteRequest(Request request,  Record record, boolean deserialize) throws KeeperException, IOException, RequestProcessorException
+    {
+        zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
+        DeleteRequest deleteRequest = (DeleteRequest) record;
+        if (deserialize) {
+            ByteBufferInputStream.byteBuffer2Record(request.request, deleteRequest);
+        }
+        String path = deleteRequest.getPath();
+        String parentPath = getParentPathAndValidate(path);
+        ChangeRecord parentRecord = getRecordForPath(parentPath);
+        zks.checkACL(request.cnxn, parentRecord.acl, ZooDefs.Perms.DELETE, request.authInfo, path, null);
+        ChangeRecord nodeRecord = getRecordForPath(path);
+        checkAndIncVersion(nodeRecord.stat.getVersion(), deleteRequest.getVersion(), path);
+        if (nodeRecord.childCount > 0) {
+            throw new KeeperException.NotEmptyException(path);
+        }
+        request.setTxn(new DeleteTxn(path));
+        parentRecord = parentRecord.duplicate(request.getHdr().getZxid());
+        parentRecord.childCount--;
+        parentRecord.stat.setPzxid(request.getHdr().getZxid());
+        parentRecord.precalculatedDigest = precalculateDigest(
+                DigestOpCode.UPDATE, parentPath, parentRecord.data, parentRecord.stat);
+        addChangeRecord(parentRecord);
 
-            String newMembers = reconfigRequest.getNewMembers();
+        nodeRecord = new ChangeRecord(request.getHdr().getZxid(), path, null, -1, null);
+        nodeRecord.precalculatedDigest = precalculateDigest(DigestOpCode.REMOVE, path);
+        setTxnDigest(request, nodeRecord.precalculatedDigest);
+        addChangeRecord(nodeRecord);
+    }
 
-            if (newMembers != null) { //non-incremental membership change
-                LOG.info("Non-incremental reconfig");
+    @MarkedOpFunc("setData")
+    void setDataRequest(Request request, long zxid, Record record, boolean deserialize) throws KeeperException, IOException, RequestProcessorException
+    {
+        zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
+        SetDataRequest setDataRequest = (SetDataRequest) record;
+        if (deserialize) {
+            ByteBufferInputStream.byteBuffer2Record(request.request, setDataRequest);
+        }
+        String path = setDataRequest.getPath();
+        validatePath(path, request.sessionId);
+        ChangeRecord nodeRecord = getRecordForPath(path);
+        zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.WRITE, request.authInfo, path, null);
+        int newVersion = checkAndIncVersion(nodeRecord.stat.getVersion(), setDataRequest.getVersion(), path);
+        request.setTxn(new SetDataTxn(path, setDataRequest.getData(), newVersion));
+        nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());
+        nodeRecord.stat.setVersion(newVersion);
+        nodeRecord.stat.setMtime(request.getHdr().getTime());
+        nodeRecord.stat.setMzxid(zxid);
+        nodeRecord.data = setDataRequest.getData();
+        nodeRecord.precalculatedDigest = precalculateDigest(
+                DigestOpCode.UPDATE, path, nodeRecord.data, nodeRecord.stat);
+        setTxnDigest(request, nodeRecord.precalculatedDigest);
+        addChangeRecord(nodeRecord);
+    }
 
-                // Input may be delimited by either commas or newlines so convert to common newline separated format
-                newMembers = newMembers.replaceAll(",", "\n");
+    @MarkedOpFunc("reconfig")
+    void reconfigRequest(Request request, long zxid, Record record, boolean deserialize) throws KeeperException, IOException, RequestProcessorException
+    {
+        if (!zks.isReconfigEnabled()) {
+            LOG.error("Reconfig operation requested but reconfig feature is disabled.");
+            throw new KeeperException.ReconfigDisabledException();
+        }
 
-                try {
-                    Properties props = new Properties();
-                    props.load(new StringReader(newMembers));
-                    request.qv = QuorumPeerConfig.parseDynamicConfig(props, lzks.self.getElectionType(), true, false);
-                    request.qv.setVersion(request.getHdr().getZxid());
-                } catch (IOException | ConfigException e) {
-                    throw new KeeperException.BadArgumentsException(e.getMessage());
-                }
-            } else { //incremental change - must be a majority quorum system
-                LOG.info("Incremental reconfig");
+        if (ZooKeeperServer.skipACL) {
+            LOG.warn("skipACL is set, reconfig operation will skip ACL checks!");
+        }
 
-                List<String> joiningServers = null;
-                String joiningServersString = reconfigRequest.getJoiningServers();
-                if (joiningServersString != null) {
-                    joiningServers = StringUtils.split(joiningServersString, ",");
-                }
+        zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
+        LeaderZooKeeperServer lzks;
+        try {
+            lzks = (LeaderZooKeeperServer) zks;
+        } catch (ClassCastException e) {
+            // standalone mode - reconfiguration currently not supported
+            throw new KeeperException.UnimplementedException();
+        }
+        QuorumVerifier lastSeenQV = lzks.self.getLastSeenQuorumVerifier();
+        // check that there's no reconfig in progress
+        if (lastSeenQV.getVersion() != lzks.self.getQuorumVerifier().getVersion()) {
+            throw new KeeperException.ReconfigInProgress();
+        }
+        ReconfigRequest reconfigRequest = (ReconfigRequest) record;
+        long configId = reconfigRequest.getCurConfigId();
+
+        if (configId != -1 && configId != lzks.self.getLastSeenQuorumVerifier().getVersion()) {
+            String msg = "Reconfiguration from version "
+                            + configId
+                            + " failed -- last seen version is "
+                            + lzks.self.getLastSeenQuorumVerifier().getVersion();
+            throw new KeeperException.BadVersionException(msg);
+        }
 
-                List<String> leavingServers = null;
-                String leavingServersString = reconfigRequest.getLeavingServers();
-                if (leavingServersString != null) {
-                    leavingServers = StringUtils.split(leavingServersString, ",");
-                }
+        String newMembers = reconfigRequest.getNewMembers();
 
-                if (!(lastSeenQV instanceof QuorumMaj)) {
-                    String msg = "Incremental reconfiguration requested but last configuration seen has a non-majority quorum system";
-                    LOG.warn(msg);
-                    throw new KeeperException.BadArgumentsException(msg);
-                }
-                Map<Long, QuorumServer> nextServers = new HashMap<Long, QuorumServer>(lastSeenQV.getAllMembers());
-                try {
-                    if (leavingServers != null) {
-                        for (String leaving : leavingServers) {
-                            long sid = Long.parseLong(leaving);
-                            nextServers.remove(sid);
-                        }
-                    }
-                    if (joiningServers != null) {
-                        for (String joiner : joiningServers) {
-                            // joiner should have the following format: server.x = server_spec;client_spec
-                            String[] parts = StringUtils.split(joiner, "=").toArray(new String[0]);
-                            if (parts.length != 2) {
-                                throw new KeeperException.BadArgumentsException("Wrong format of server string");
-                            }
-                            // extract server id x from first part of joiner: server.x
-                            Long sid = Long.parseLong(parts[0].substring(parts[0].lastIndexOf('.') + 1));
-                            QuorumServer qs = new QuorumServer(sid, parts[1]);
-                            if (qs.clientAddr == null || qs.electionAddr == null || qs.addr == null) {
-                                throw new KeeperException.BadArgumentsException("Wrong format of server string - each server should have 3 ports specified");
-                            }
+        if (newMembers != null) { //non-incremental membership change
+            LOG.info("Non-incremental reconfig");
 
-                            // check duplication of addresses and ports
-                            for (QuorumServer nqs : nextServers.values()) {
-                                if (qs.id == nqs.id) {
-                                    continue;
-                                }
-                                qs.checkAddressDuplicate(nqs);
-                            }
+            // Input may be delimited by either commas or newlines so convert to common newline separated format
+            newMembers = newMembers.replaceAll(",", "\n");
 
-                            nextServers.remove(qs.id);
-                            nextServers.put(qs.id, qs);
-                        }
-                    }
-                } catch (ConfigException e) {
-                    throw new KeeperException.BadArgumentsException("Reconfiguration failed");
-                }
-                request.qv = new QuorumMaj(nextServers);
+            try {
+                Properties props = new Properties();
+                props.load(new StringReader(newMembers));
+                request.qv = QuorumPeerConfig.parseDynamicConfig(props, lzks.self.getElectionType(), true, false);
                 request.qv.setVersion(request.getHdr().getZxid());
+            } catch (IOException | ConfigException e) {
+                throw new KeeperException.BadArgumentsException(e.getMessage());
             }
-            if (QuorumPeerConfig.isStandaloneEnabled() && request.qv.getVotingMembers().size() < 2) {
-                String msg = "Reconfig failed - new configuration must include at least 2 followers";
-                LOG.warn(msg);
-                throw new KeeperException.BadArgumentsException(msg);
-            } else if (request.qv.getVotingMembers().size() < 1) {
-                String msg = "Reconfig failed - new configuration must include at least 1 follower";
-                LOG.warn(msg);
-                throw new KeeperException.BadArgumentsException(msg);
+        } else { //incremental change - must be a majority quorum system
+            LOG.info("Incremental reconfig");
+
+            List<String> joiningServers = null;
+            String joiningServersString = reconfigRequest.getJoiningServers();
+            if (joiningServersString != null) {
+                joiningServers = StringUtils.split(joiningServersString, ",");
             }
 
-            if (!lzks.getLeader().isQuorumSynced(request.qv)) {
-                String msg2 = "Reconfig failed - there must be a connected and synced quorum in new configuration";
-                LOG.warn(msg2);
-                throw new KeeperException.NewConfigNoQuorum();
+            List<String> leavingServers = null;
+            String leavingServersString = reconfigRequest.getLeavingServers();
+            if (leavingServersString != null) {
+                leavingServers = StringUtils.split(leavingServersString, ",");
             }
 
-            nodeRecord = getRecordForPath(ZooDefs.CONFIG_NODE);
-            zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.WRITE, request.authInfo, null, null);
-            SetDataTxn setDataTxn = new SetDataTxn(ZooDefs.CONFIG_NODE, request.qv.toString().getBytes(), -1);
-            request.setTxn(setDataTxn);
-            nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());
-            nodeRecord.stat.setVersion(-1);
-            nodeRecord.stat.setMtime(request.getHdr().getTime());
-            nodeRecord.stat.setMzxid(zxid);
-            nodeRecord.data = setDataTxn.getData();
-            // Reconfig is currently a noop from digest computation
-            // perspective since config node is not covered by the digests.
-            nodeRecord.precalculatedDigest = precalculateDigest(
-                    DigestOpCode.NOOP, ZooDefs.CONFIG_NODE, nodeRecord.data, nodeRecord.stat);
-            setTxnDigest(request, nodeRecord.precalculatedDigest);
-            addChangeRecord(nodeRecord);
-
-            break;
-        case OpCode.setACL:
-            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
-            SetACLRequest setAclRequest = (SetACLRequest) record;
-            if (deserialize) {
-                ByteBufferInputStream.byteBuffer2Record(request.request, setAclRequest);
+            if (!(lastSeenQV instanceof QuorumMaj)) {
+                String msg = "Incremental reconfiguration requested but last configuration seen has a non-majority quorum system";
+                LOG.warn(msg);
+                throw new KeeperException.BadArgumentsException(msg);
             }
-            path = setAclRequest.getPath();
-            validatePath(path, request.sessionId);
-            List<ACL> listACL = fixupACL(path, request.authInfo, setAclRequest.getAcl());
-            nodeRecord = getRecordForPath(path);
-            zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.ADMIN, request.authInfo, path, listACL);
-            newVersion = checkAndIncVersion(nodeRecord.stat.getAversion(), setAclRequest.getVersion(), path);
-            request.setTxn(new SetACLTxn(path, listACL, newVersion));
-            nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());
-            nodeRecord.stat.setAversion(newVersion);
-            nodeRecord.precalculatedDigest = precalculateDigest(
-                    DigestOpCode.UPDATE, path, nodeRecord.data, nodeRecord.stat);
-            setTxnDigest(request, nodeRecord.precalculatedDigest);
-            addChangeRecord(nodeRecord);
-            break;
-        case OpCode.createSession:
-            request.request.rewind();
-            int to = request.request.getInt();
-            request.setTxn(new CreateSessionTxn(to));
-            request.request.rewind();
-            // only add the global session tracker but not to ZKDb
-            zks.sessionTracker.trackSession(request.sessionId, to);
-            zks.setOwner(request.sessionId, request.getOwner());
-            break;
-        case OpCode.closeSession:
-            // We don't want to do this check since the session expiration thread
-            // queues up this operation without being the session owner.
-            // this request is the last of the session so it should be ok
-            //zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
-            long startTime = Time.currentElapsedTime();
-            synchronized (zks.outstandingChanges) {
-                // need to move getEphemerals into zks.outstandingChanges
-                // synchronized block, otherwise there will be a race
-                // condition with the on flying deleteNode txn, and we'll
-                // delete the node again here, which is not correct
-                Set<String> es = zks.getZKDatabase().getEphemerals(request.sessionId);
-                for (ChangeRecord c : zks.outstandingChanges) {
-                    if (c.stat == null) {
-                        // Doing a delete
-                        es.remove(c.path);
-                    } else if (c.stat.getEphemeralOwner() == request.sessionId) {
-                        es.add(c.path);
+            Map<Long, QuorumServer> nextServers = new HashMap<Long, QuorumServer>(lastSeenQV.getAllMembers());
+            try {
+                if (leavingServers != null) {
+                    for (String leaving : leavingServers) {
+                        long sid = Long.parseLong(leaving);
+                        nextServers.remove(sid);
                     }
                 }
-                for (String path2Delete : es) {
-                    if (digestEnabled) {
-                        parentPath = getParentPathAndValidate(path2Delete);
-                        parentRecord = getRecordForPath(parentPath);
-                        parentRecord = parentRecord.duplicate(request.getHdr().getZxid());
-                        parentRecord.stat.setPzxid(request.getHdr().getZxid());
-                        parentRecord.precalculatedDigest = precalculateDigest(
-                                DigestOpCode.UPDATE, parentPath, parentRecord.data, parentRecord.stat);
-                        addChangeRecord(parentRecord);
+                if (joiningServers != null) {
+                    for (String joiner : joiningServers) {
+                        // joiner should have the following format: server.x = server_spec;client_spec
+                        String[] parts = StringUtils.split(joiner, "=").toArray(new String[0]);
+                        if (parts.length != 2) {
+                            throw new KeeperException.BadArgumentsException("Wrong format of server string");
+                        }
+                        // extract server id x from first part of joiner: server.x
+                        Long sid = Long.parseLong(parts[0].substring(parts[0].lastIndexOf('.') + 1));
+                        QuorumServer qs = new QuorumServer(sid, parts[1]);
+                        if (qs.clientAddr == null || qs.electionAddr == null || qs.addr == null) {
+                            throw new KeeperException.BadArgumentsException("Wrong format of server string - each server should have 3 ports specified");
+                        }
+
+                        // check duplication of addresses and ports
+                        for (QuorumServer nqs : nextServers.values()) {
+                            if (qs.id == nqs.id) {
+                                continue;
+                            }
+                            qs.checkAddressDuplicate(nqs);
+                        }
+
+                        nextServers.remove(qs.id);
+                        nextServers.put(qs.id, qs);
                     }
-                    nodeRecord = new ChangeRecord(
-                            request.getHdr().getZxid(), path2Delete, null, 0, null);
-                    nodeRecord.precalculatedDigest = precalculateDigest(
-                            DigestOpCode.REMOVE, path2Delete);
-                    addChangeRecord(nodeRecord);
                 }
-                if (ZooKeeperServer.isCloseSessionTxnEnabled()) {
-                    request.setTxn(new CloseSessionTxn(new ArrayList<String>(es)));
+            } catch (ConfigException e) {
+                throw new KeeperException.BadArgumentsException("Reconfiguration failed");
+            }
+            request.qv = new QuorumMaj(nextServers);
+            request.qv.setVersion(request.getHdr().getZxid());
+        }
+        if (QuorumPeerConfig.isStandaloneEnabled() && request.qv.getVotingMembers().size() < 2) {
+            String msg = "Reconfig failed - new configuration must include at least 2 followers";
+            LOG.warn(msg);
+            throw new KeeperException.BadArgumentsException(msg);
+        } else if (request.qv.getVotingMembers().size() < 1) {
+            String msg = "Reconfig failed - new configuration must include at least 1 follower";
+            LOG.warn(msg);
+            throw new KeeperException.BadArgumentsException(msg);
+        }
+
+        if (!lzks.getLeader().isQuorumSynced(request.qv)) {
+            String msg2 = "Reconfig failed - there must be a connected and synced quorum in new configuration";
+            LOG.warn(msg2);
+            throw new KeeperException.NewConfigNoQuorum();
+        }
+
+        ChangeRecord nodeRecord = getRecordForPath(ZooDefs.CONFIG_NODE);
+        zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.WRITE, request.authInfo, null, null);
+        SetDataTxn setDataTxn = new SetDataTxn(ZooDefs.CONFIG_NODE, request.qv.toString().getBytes(), -1);
+        request.setTxn(setDataTxn);
+        nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());
+        nodeRecord.stat.setVersion(-1);
+        nodeRecord.stat.setMtime(request.getHdr().getTime());
+        nodeRecord.stat.setMzxid(zxid);
+        nodeRecord.data = setDataTxn.getData();
+        // Reconfig is currently a noop from digest computation
+        // perspective since config node is not covered by the digests.
+        nodeRecord.precalculatedDigest = precalculateDigest(
+                DigestOpCode.NOOP, ZooDefs.CONFIG_NODE, nodeRecord.data, nodeRecord.stat);
+        setTxnDigest(request, nodeRecord.precalculatedDigest);
+        addChangeRecord(nodeRecord);
+    }
+
+    @MarkedOpFunc("setACL")
+    void setACLRequest(Request request,  Record record, boolean deserialize) throws KeeperException, IOException, RequestProcessorException
+    {
+        zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
+        SetACLRequest setAclRequest = (SetACLRequest) record;
+        if (deserialize) {
+            ByteBufferInputStream.byteBuffer2Record(request.request, setAclRequest);
+        }
+        String path = setAclRequest.getPath();
+        validatePath(path, request.sessionId);
+        List<ACL> listACL = fixupACL(path, request.authInfo, setAclRequest.getAcl());
+        ChangeRecord nodeRecord = getRecordForPath(path);
+        zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.ADMIN, request.authInfo, path, listACL);
+        int newVersion = checkAndIncVersion(nodeRecord.stat.getAversion(), setAclRequest.getVersion(), path);
+        request.setTxn(new SetACLTxn(path, listACL, newVersion));
+        nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());
+        nodeRecord.stat.setAversion(newVersion);
+        nodeRecord.precalculatedDigest = precalculateDigest(
+                DigestOpCode.UPDATE, path, nodeRecord.data, nodeRecord.stat);
+        setTxnDigest(request, nodeRecord.precalculatedDigest);
+        addChangeRecord(nodeRecord);
+    }
+
+    @MarkedOpFunc("createSession")
+    void createSessionRequest(Request request,  Record record, boolean deserialize) throws KeeperException, IOException, RequestProcessorException
+    {
+        request.request.rewind();
+        int to = request.request.getInt();
+        request.setTxn(new CreateSessionTxn(to));
+        request.request.rewind();
+        // only add the global session tracker but not to ZKDb
+        zks.sessionTracker.trackSession(request.sessionId, to);
+        zks.setOwner(request.sessionId, request.getOwner());
+    }
+
+    @MarkedOpFunc("closeSession")
+    void closeSessionRequest(Request request,  Record record, boolean deserialize) throws KeeperException, IOException, RequestProcessorException
+    {
+        // We don't want to do this check since the session expiration thread
+        // queues up this operation without being the session owner.
+        // this request is the last of the session so it should be ok
+        //zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
+        long startTime = Time.currentElapsedTime();
+        synchronized (zks.outstandingChanges) {
+            // need to move getEphemerals into zks.outstandingChanges
+            // synchronized block, otherwise there will be a race
+            // condition with the on flying deleteNode txn, and we'll
+            // delete the node again here, which is not correct
+            Set<String> es = zks.getZKDatabase().getEphemerals(request.sessionId);
+            for (ChangeRecord c : zks.outstandingChanges) {
+                if (c.stat == null) {
+                    // Doing a delete
+                    es.remove(c.path);
+                } else if (c.stat.getEphemeralOwner() == request.sessionId) {
+                    es.add(c.path);
                 }
-                zks.sessionTracker.setSessionClosing(request.sessionId);
             }
-            ServerMetrics.getMetrics().CLOSE_SESSION_PREP_TIME.add(Time.currentElapsedTime() - startTime);
-            break;
-        case OpCode.check:
-            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
-            CheckVersionRequest checkVersionRequest = (CheckVersionRequest) record;
-            if (deserialize) {
-                ByteBufferInputStream.byteBuffer2Record(request.request, checkVersionRequest);
+            for (String path2Delete : es) {
+                if (digestEnabled) {
+                    String parentPath = getParentPathAndValidate(path2Delete);
+                    ChangeRecord parentRecord = getRecordForPath(parentPath);
+                    parentRecord = parentRecord.duplicate(request.getHdr().getZxid());
+                    parentRecord.stat.setPzxid(request.getHdr().getZxid());
+                    parentRecord.precalculatedDigest = precalculateDigest(
+                            DigestOpCode.UPDATE, parentPath, parentRecord.data, parentRecord.stat);
+                    addChangeRecord(parentRecord);
+                }
+                ChangeRecord nodeRecord = new ChangeRecord(
+                        request.getHdr().getZxid(), path2Delete, null, 0, null);
+                nodeRecord.precalculatedDigest = precalculateDigest(
+                        DigestOpCode.REMOVE, path2Delete);
+                addChangeRecord(nodeRecord);
+            }
+            if (ZooKeeperServer.isCloseSessionTxnEnabled()) {
+                request.setTxn(new CloseSessionTxn(new ArrayList<String>(es)));
+            }
+            zks.sessionTracker.setSessionClosing(request.sessionId);
+        }
+        ServerMetrics.getMetrics().CLOSE_SESSION_PREP_TIME.add(Time.currentElapsedTime() - startTime);
+    }
+
+    @MarkedOpFunc("check")
+    void checkRequest(Request request,  Record record, boolean deserialize) throws KeeperException, IOException, RequestProcessorException
+    {
+        zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
+        CheckVersionRequest checkVersionRequest = (CheckVersionRequest) record;
+        if (deserialize) {
+            ByteBufferInputStream.byteBuffer2Record(request.request, checkVersionRequest);
+        }
+        String path = checkVersionRequest.getPath();
+        validatePath(path, request.sessionId);
+        ChangeRecord nodeRecord = getRecordForPath(path);
+        zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.READ, request.authInfo, path, null);
+        request.setTxn(new CheckVersionTxn(
+            path,
+            checkAndIncVersion(nodeRecord.stat.getVersion(), checkVersionRequest.getVersion(), path)));
+    }
+
+    /**
+     * This method will be called inside the ProcessRequestThread, which is a
+     * singleton, so there will be a single thread calling this code.
+     *
+     * @param type
+     * @param zxid
+     * @param request
+     * @param record
+     */
+    protected void pRequest2Txn(int type, long zxid, Request request, Record record, boolean deserialize) throws KeeperException, IOException, RequestProcessorException {
+        if (request.getHdr() == null) {
+            request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid,
+                    Time.currentWallTime(), type));
+        }
+
+        PrecalculatedDigest precalculatedDigest;
+        switch (type) {
+            case OpCode.create:
+                createRequest(type, request, record, deserialize);
+                break;
+            case OpCode.create2:
+                create2Request(type, request, record, deserialize);
+                break;
+            case OpCode.createTTL:
+                createTTLRequest(type, request, record, deserialize);
+                break;
+            case OpCode.createContainer: {
+                createContainerRequest(type, request, record, deserialize);
+                break;
+            }
+            case OpCode.deleteContainer: {
+                deleteContainerRequest(request, record, deserialize);
+                break;
             }
-            path = checkVersionRequest.getPath();
-            validatePath(path, request.sessionId);
-            nodeRecord = getRecordForPath(path);
-            zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.READ, request.authInfo, path, null);
-            request.setTxn(new CheckVersionTxn(
-                path,
-                checkAndIncVersion(nodeRecord.stat.getVersion(), checkVersionRequest.getVersion(), path)));
-            break;
-        default:
-            LOG.warn("unknown type {}", type);
-            break;
+            case OpCode.delete:
+                deleteRequest(request, record, deserialize);
+                break;
+            case OpCode.setData:
+                setDataRequest(request, zxid, record, deserialize);
+                break;
+            case OpCode.reconfig:
+                reconfigRequest(request, zxid, record, deserialize);
+                break;
+            case OpCode.setACL:
+                setACLRequest(request, record, deserialize);
+                break;
+            case OpCode.createSession:
+                createSessionRequest(request, record, deserialize);
+                break;
+            case OpCode.closeSession:
+                closeSessionRequest(request, record, deserialize);
+                break;
+            case OpCode.check:
+                checkRequest(request, record, deserialize);
+                break;
+            default:
+                LOG.warn("unknown type {}", type);
+                break;
         }
 
         // If the txn is not going to mutate anything, like createSession,
diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/Request.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/Request.java
index d0fb7da4d..9e1196950 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/Request.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/Request.java
@@ -18,6 +18,7 @@
 
 package org.apache.zookeeper.server;
 
+import edu.jhu.order.t2c.dynamicd.runtime.MarkedOpSubfields;
 import java.nio.ByteBuffer;
 import java.util.List;
 import org.apache.jute.Record;
@@ -70,10 +71,13 @@ public Request(long sessionId, int xid, int type, TxnHeader hdr, Record txn, lon
         this.authInfo = null;
     }
 
+    @MarkedOpSubfields
     public final long sessionId;
 
+    @MarkedOpSubfields
     public final int cxid;
 
+    @MarkedOpSubfields
     public final int type;
 
     public final ByteBuffer request;
@@ -84,6 +88,7 @@ public Request(long sessionId, int xid, int type, TxnHeader hdr, Record txn, lon
 
     private Record txn;
 
+    @MarkedOpSubfields
     public long zxid = -1;
 
     public final List<Id> authInfo;
diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
index ef13d7470..852aeb40f 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
@@ -63,6 +63,9 @@
 public class QuorumPeerConfig {
 
     private static final Logger LOG = LoggerFactory.getLogger(QuorumPeerConfig.class);
+
+    public static QuorumPeerConfig sharedConfig = null;
+
     private static final int UNSET_SERVERID = -1;
     public static final String nextDynamicConfigFileSuffix = ".dynamic.next";
 
@@ -171,6 +174,9 @@ public ConfigException(String msg, Exception e) {
      * @throws ConfigException error processing configuration
      */
     public void parse(String path) throws ConfigException {
+        // CHANG: saved this config instance
+        sharedConfig = this;
+
         LOG.info("Reading configuration from: " + path);
 
         try {
diff --git a/zookeeper-server/src/test/java/org/apache/zookeeper/ZooKeeperTest.java b/zookeeper-server/src/test/java/org/apache/zookeeper/ZooKeeperTest.java
index 4467a1ac4..5e375d87d 100644
--- a/zookeeper-server/src/test/java/org/apache/zookeeper/ZooKeeperTest.java
+++ b/zookeeper-server/src/test/java/org/apache/zookeeper/ZooKeeperTest.java
@@ -59,7 +59,7 @@ public class ZooKeeperTest extends ClientBase {
 
     private static final String LINE_SEPARATOR = System.getProperty("line.separator", "\n");
 
-    @Test
+    // @Test
     public void testDeleteRecursive() throws IOException, InterruptedException, KeeperException {
         final ZooKeeper zk = createClient();
         setupDataTree(zk);
@@ -73,7 +73,7 @@ public void testDeleteRecursive() throws IOException, InterruptedException, Keep
         assertNull(zk.exists("/a", null));
     }
 
-    @Test
+    // @Test
     public void testDeleteRecursiveFail() throws IOException, InterruptedException, KeeperException {
         final ZooKeeper zk = createClient();
         setupDataTree(zk);
@@ -160,7 +160,7 @@ public void testDeleteRecursiveCli() throws IOException, InterruptedException, C
         assertNull(zk.exists("/a", null));
     }
 
-    @Test
+    // @Test
     public void testDeleteRecursiveAsync() throws IOException, InterruptedException, KeeperException {
         final ZooKeeper zk = createClient();
         // making sure setdata works on /
@@ -205,7 +205,7 @@ public void processResult(int rc, String path, Object ctx) {
         assertEquals(4, ctx.get());
     }
 
-    @Test
+    // @Test
     public void testStatWhenPathDoesNotExist() throws IOException, InterruptedException, MalformedCommandException {
         final ZooKeeper zk = createClient();
         ZooKeeperMain main = new ZooKeeperMain(zk);
@@ -219,7 +219,7 @@ public void testStatWhenPathDoesNotExist() throws IOException, InterruptedExcept
         }
     }
 
-    @Test
+    // @Test
     public void testParseWithExtraSpaces() throws Exception {
         final ZooKeeper zk = createClient();
         ZooKeeperMain zkMain = new ZooKeeperMain(zk);
@@ -230,7 +230,7 @@ public void testParseWithExtraSpaces() throws Exception {
         assertEquals("/ is not taken as second argument", zkMain.cl.getCmdArgument(1), "/");
     }
 
-    @Test
+    // @Test
     public void testParseWithQuotes() throws Exception {
         final ZooKeeper zk = createClient();
         ZooKeeperMain zkMain = new ZooKeeperMain(zk);
@@ -244,7 +244,7 @@ public void testParseWithQuotes() throws Exception {
         }
     }
 
-    @Test
+    // @Test
     public void testParseWithMixedQuotes() throws Exception {
         final ZooKeeper zk = createClient();
         ZooKeeperMain zkMain = new ZooKeeperMain(zk);
@@ -263,7 +263,7 @@ public void testParseWithMixedQuotes() throws Exception {
         }
     }
 
-    @Test
+    // @Test
     public void testParseWithEmptyQuotes() throws Exception {
         final ZooKeeper zk = createClient();
         ZooKeeperMain zkMain = new ZooKeeperMain(zk);
@@ -275,7 +275,7 @@ public void testParseWithEmptyQuotes() throws Exception {
         assertEquals("empty string is not taken as third argument", zkMain.cl.getCmdArgument(2), "");
     }
 
-    @Test
+    // @Test
     public void testParseWithMultipleQuotes() throws Exception {
         final ZooKeeper zk = createClient();
         ZooKeeperMain zkMain = new ZooKeeperMain(zk);
@@ -288,27 +288,27 @@ public void testParseWithMultipleQuotes() throws Exception {
         assertEquals("empty string is not taken as fourth argument", zkMain.cl.getCmdArgument(3), "");
     }
 
-    @Test
+    // @Test
     public void testNonexistantCommand() throws Exception {
         testInvalidCommand("cret -s /node1", 127);
     }
 
-    @Test
+    // @Test
     public void testCreateCommandWithoutPath() throws Exception {
         testInvalidCommand("create", 1);
     }
 
-    @Test
+    // @Test
     public void testCreateEphemeralCommandWithoutPath() throws Exception {
         testInvalidCommand("create -e ", 1);
     }
 
-    @Test
+    // @Test
     public void testCreateSequentialCommandWithoutPath() throws Exception {
         testInvalidCommand("create -s ", 1);
     }
 
-    @Test
+    // @Test
     public void testCreateEphemeralSequentialCommandWithoutPath() throws Exception {
         testInvalidCommand("create -s -e ", 1);
     }
@@ -332,7 +332,7 @@ private void testInvalidCommand(String cmdString, int exitCode) throws Exception
         fail("invalid command should throw CliException");
     }
 
-    @Test
+    // @Test
     public void testCreateNodeWithoutData() throws Exception {
         final ZooKeeper zk = createClient();
         ZooKeeperMain zkMain = new ZooKeeperMain(zk);
@@ -359,7 +359,7 @@ public void testCreateNodeWithoutData() throws Exception {
         }
     }
 
-    @Test
+    // @Test
     public void testACLWithExtraAgruments() throws Exception {
         final ZooKeeper zk = createClient();
         ZooKeeperMain zkMain = new ZooKeeperMain(zk);
@@ -369,7 +369,7 @@ public void testACLWithExtraAgruments() throws Exception {
         assertTrue("Not considering the extra arguments after the acls.", zkMain.processZKCmd(zkMain.cl));
     }
 
-    @Test
+    // @Test
     public void testCreatePersistentNode() throws Exception {
         final ZooKeeper zk = createClient();
         ZooKeeperMain zkMain = new ZooKeeperMain(zk);
@@ -378,7 +378,7 @@ public void testCreatePersistentNode() throws Exception {
         assertTrue("Not creating Persistent node.", zkMain.processZKCmd(zkMain.cl));
     }
 
-    @Test
+    // @Test
     public void testDelete() throws Exception {
         final ZooKeeper zk = createClient();
         ZooKeeperMain zkMain = new ZooKeeperMain(zk);
@@ -393,12 +393,12 @@ public void testDelete() throws Exception {
         assertFalse("", zkMain.processCmd(zkMain.cl));
     }
 
-    @Test
+    // @Test
     public void testDeleteNonexistantNode() throws Exception {
         testInvalidCommand("delete /blahblahblah", 1);
     }
 
-    @Test
+    // @Test
     public void testStatCommand() throws Exception {
         final ZooKeeper zk = createClient();
         ZooKeeperMain zkMain = new ZooKeeperMain(zk);
@@ -413,7 +413,7 @@ public void testStatCommand() throws Exception {
         assertFalse(zkMain.processZKCmd(zkMain.cl));
     }
 
-    @Test
+    // @Test
     public void testInvalidStatCommand() throws Exception {
         final ZooKeeper zk = createClient();
         ZooKeeperMain zkMain = new ZooKeeperMain(zk);
@@ -428,7 +428,7 @@ public void testInvalidStatCommand() throws Exception {
         }
     }
 
-    @Test
+    // @Test
     public void testSetData() throws Exception {
         final ZooKeeper zk = createClient();
         ZooKeeperMain zkMain = new ZooKeeperMain(zk);
@@ -449,7 +449,7 @@ public void testSetData() throws Exception {
         assertFalse(zkMain.processZKCmd(zkMain.cl));
     }
 
-    @Test
+    // @Test
     public void testCheckInvalidAcls() throws Exception {
         final ZooKeeper zk = createClient();
         ZooKeeperMain zkMain = new ZooKeeperMain(zk);
@@ -459,7 +459,7 @@ public void testCheckInvalidAcls() throws Exception {
         zkMain.executeLine(cmdstring);
     }
 
-    @Test
+    // @Test
     public void testDeleteWithInvalidVersionNo() throws Exception {
         final ZooKeeper zk = createClient();
         ZooKeeperMain zkMain = new ZooKeeperMain(zk);
@@ -471,7 +471,7 @@ public void testDeleteWithInvalidVersionNo() throws Exception {
         zkMain.executeLine(cmdstring1);
     }
 
-    @Test
+    // @Test
     public void testCliCommandsNotEchoingUsage() throws Exception {
         // setup redirect out/err streams to get System.in/err, use this judiciously!
         final PrintStream systemErr = System.err; // get current err
@@ -493,7 +493,7 @@ public void testCliCommandsNotEchoingUsage() throws Exception {
     }
 
     // ZOOKEEPER-2467 : Testing negative number for redo command
-    @Test
+    // @Test
     public void testRedoWithNegativeCmdNumber() throws Exception {
         final ZooKeeper zk = createClient();
         ZooKeeperMain zkMain = new ZooKeeperMain(zk);
@@ -524,7 +524,7 @@ private static void runCommandExpect(CliCommand command, List<String> expectedRe
         assertTrue(result, result.contains(StringUtils.joinStrings(expectedResults, LINE_SEPARATOR)));
     }
 
-    @Test
+    // @Test
     public void testSortedLs() throws Exception {
         final ZooKeeper zk = createClient();
         ZooKeeperMain zkMain = new ZooKeeperMain(zk);
@@ -543,7 +543,7 @@ public void testSortedLs() throws Exception {
         runCommandExpect(cmd, expected);
     }
 
-    @Test
+    // @Test
     public void testLsrCommand() throws Exception {
         final ZooKeeper zk = createClient();
         ZooKeeperMain zkMain = new ZooKeeperMain(zk);
@@ -569,7 +569,7 @@ public void testLsrCommand() throws Exception {
         runCommandExpect(cmd, expected);
     }
 
-    @Test
+    // @Test
     public void testLsrRootCommand() throws Exception {
         final ZooKeeper zk = createClient();
         ZooKeeperMain zkMain = new ZooKeeperMain(zk);
@@ -584,7 +584,7 @@ public void testLsrRootCommand() throws Exception {
         runCommandExpect(cmd, expected);
     }
 
-    @Test
+    // @Test
     public void testLsrLeafCommand() throws Exception {
         final ZooKeeper zk = createClient();
         ZooKeeperMain zkMain = new ZooKeeperMain(zk);
@@ -601,7 +601,7 @@ public void testLsrLeafCommand() throws Exception {
         runCommandExpect(cmd, expected);
     }
 
-    @Test
+    // @Test
     public void testLsrNonexistantZnodeCommand() throws Exception {
         final ZooKeeper zk = createClient();
         ZooKeeperMain zkMain = new ZooKeeperMain(zk);
@@ -621,7 +621,7 @@ public void testLsrNonexistantZnodeCommand() throws Exception {
         }
     }
 
-    @Test
+    // @Test
     public void testSetAclRecursive() throws Exception {
         final ZooKeeper zk = createClient();
         final byte[] EMPTY = new byte[0];
@@ -646,7 +646,7 @@ public void testSetAclRecursive() throws Exception {
         assertEquals(Ids.OPEN_ACL_UNSAFE, zk.getACL("/e", new Stat()));
     }
 
-    @Test
+    // @Test
     public void testClientReconnectWithZKClientConfig() throws Exception {
         ZooKeeper zk = null;
         ZooKeeper newZKClient = null;
@@ -673,7 +673,7 @@ public void testClientReconnectWithZKClientConfig() throws Exception {
         }
     }
 
-    @Test
+    // @Test
     public void testSyncCommand() throws Exception {
         final ZooKeeper zk = createClient();
         SyncCommand cmd = new SyncCommand();
