diff --git a/bin/zkEnv.sh b/bin/zkEnv.sh
index 08519181b..017605714 100755
--- a/bin/zkEnv.sh
+++ b/bin/zkEnv.sh
@@ -115,6 +115,8 @@ done
 
 #make it work for developers
 CLASSPATH="$ZOOBINDIR/../build/classes:$CLASSPATH"
+#CHANG: load testing classes at runtime
+CLASSPATH="$ZOOBINDIR/../build/test/classes:$CLASSPATH"
 
 case "`uname`" in
     CYGWIN*) cygwin=true ;;
diff --git a/bin/zkServer.sh b/bin/zkServer.sh
index 23d1e2132..06717377b 100755
--- a/bin/zkServer.sh
+++ b/bin/zkServer.sh
@@ -53,6 +53,7 @@ else
   . "$ZOOBINDIR"/zkEnv.sh
 fi
 
+JMXDISABLE="true"
 if [ "x$SERVER_JVMFLAGS" != "x" ]
 then
     JVMFLAGS="$SERVER_JVMFLAGS $JVMFLAGS"
@@ -123,9 +124,10 @@ start)
          exit 0
       fi
     fi
+    T2CFLAGS="-Dt2c.mode=prod -Dconf=CONF_PATH_MACRO -Dt2c.t2c_root_abs_path=T2C_DIR_MACRO -Dt2c.target_system_abs_path=SYS_DIR_MACRO"
     nohup "$JAVA" $ZOO_DATADIR_AUTOCREATE "-Dzookeeper.log.dir=${ZOO_LOG_DIR}" \
     "-Dzookeeper.root.logger=${ZOO_LOG4J_PROP}" \
-    -cp "$CLASSPATH" $JVMFLAGS $ZOOMAIN "$ZOOCFG" > "$_ZOO_DAEMON_OUT" 2>&1 < /dev/null &
+    -cp "$CLASSPATH" $JVMFLAGS "-Dreadonlymode.enabled=true" $T2CFLAGS edu.jhu.order.t2c.dynamicd.runtime.MainWrapper $ZOOMAIN "$ZOOCFG" > "$_ZOO_DAEMON_OUT" 2>&1 < /dev/null &
     if [ $? -eq 0 ]
     then
       if /bin/echo -n $! > "$ZOOPIDFILE"
diff --git a/build.xml b/build.xml
index 9283a2fc7..1177e49b2 100644
--- a/build.xml
+++ b/build.xml
@@ -103,7 +103,7 @@ xmlns:maven="antlib:org.apache.maven.artifact.ant">
 
     <property name="ivy.version" value="2.2.0"/>
     <property name="ivy.url"
-              value="http://repo2.maven.org/maven2/org/apache/ivy/ivy" />
+              value="https://repo1.maven.org/maven2/org/apache/ivy/ivy" />
     <property name="ivy.home" value="${user.home}/.ant" />
     <property name="ivy.lib" value="${build.dir}/lib"/>
     <property name="ivy.package.lib" value="${build.dir}/package/lib"/>
@@ -336,7 +336,7 @@ xmlns:maven="antlib:org.apache.maven.artifact.ant">
     
     <target name="build-generated" depends="compile_jute,version-info" >
         <javac srcdir="${src_generated.dir}" destdir="${build.classes}" includeantruntime="false"
-            target="${javac.target}" source="${javac.source}" debug="on" />
+            target="${javac.target}" source="${javac.source}" debug="on" classpath="T2C_DIR_MACRO/target/t2c-1.0-SNAPSHOT-jar-with-dependencies.jar"/>
     </target>
     
     <target name="ivy-download" unless="ivy.jar.exists" depends="init">
diff --git a/ivysettings.xml b/ivysettings.xml
index 52cfa52df..d7432d843 100644
--- a/ivysettings.xml
+++ b/ivysettings.xml
@@ -18,11 +18,11 @@
 -->
 
   <property name="repo.maven.org"
-    value="http://repo1.maven.org/maven2/" override="false"/>
+    value="https://repo1.maven.org/maven2/" override="false"/>
   <property name="repo.jboss.org"
-    value="http://repository.jboss.org/nexus/content/groups/public/" override="false"/>
+    value="https://repository.jboss.org/nexus/content/groups/public/" override="false"/>
   <property name="repo.sun.org"
-    value="http://download.java.net/maven/2/" override="false"/>
+    value="https://download.java.net/maven/2/" override="false"/>
   <property name="maven2.pattern"
     value="[organisation]/[module]/[revision]/[module]-[revision]"/>
   <property name="maven2.pattern.ext" value="${maven2.pattern}.[ext]"/>
diff --git a/src/java/main/org/apache/zookeeper/ZooDefs.java b/src/java/main/org/apache/zookeeper/ZooDefs.java
index 3ee5dedd0..c53956c8d 100644
--- a/src/java/main/org/apache/zookeeper/ZooDefs.java
+++ b/src/java/main/org/apache/zookeeper/ZooDefs.java
@@ -23,55 +23,56 @@ import java.util.Collections;
 
 import org.apache.zookeeper.data.ACL;
 import org.apache.zookeeper.data.Id;
+import edu.jhu.order.t2c.dynamicd.runtime.MarkedOp;
 
 public class ZooDefs {
    
    final public static String CONFIG_NODE = "/zookeeper/config";
    
     public interface OpCode {
-        public final int notification = 0;
+        @MarkedOp public final int notification = 0;
 
-        public final int create = 1;
+        @MarkedOp public final int create = 1;
 
-        public final int delete = 2;
+        @MarkedOp public final int delete = 2;
 
-        public final int exists = 3;
+        @MarkedOp(ifQueryOp=true) public final int exists = 3;
 
-        public final int getData = 4;
+        @MarkedOp(ifQueryOp=true) public final int getData = 4;
 
-        public final int setData = 5;
+        @MarkedOp public final int setData = 5;
 
-        public final int getACL = 6;
+        @MarkedOp(ifQueryOp=true) public final int getACL = 6;
 
-        public final int setACL = 7;
+        @MarkedOp public final int setACL = 7;
 
-        public final int getChildren = 8;
+        @MarkedOp(ifQueryOp=true) public final int getChildren = 8;
 
-        public final int sync = 9;
+        @MarkedOp public final int sync = 9;
 
-        public final int ping = 11;
+        @MarkedOp public final int ping = 11;
 
-        public final int getChildren2 = 12;
+        @MarkedOp(ifQueryOp=true) public final int getChildren2 = 12;
 
-        public final int check = 13;
+        @MarkedOp public final int check = 13;
 
-        public final int multi = 14;
+        @MarkedOp public final int multi = 14;
         
-        public final int create2 = 15;
+        @MarkedOp public final int create2 = 15;
 
-        public final int reconfig = 16;
+        @MarkedOp public final int reconfig = 16;
         
-        public final int auth = 100;
+        @MarkedOp public final int auth = 100;
 
-        public final int setWatches = 101;
+        @MarkedOp public final int setWatches = 101;
 
-        public final int sasl = 102;
+        @MarkedOp public final int sasl = 102;
 
-        public final int createSession = -10;
+        @MarkedOp public final int createSession = -10;
 
-        public final int closeSession = -11;
+        @MarkedOp public final int closeSession = -11;
 
-        public final int error = -1;
+        @MarkedOp public final int error = -1;
     }
 
     public interface Perms {
diff --git a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
index e369c3846..b3a5cf949 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
@@ -88,6 +88,7 @@ public class ZooKeeperMain {
         commandMap.put("redo","cmdno");
         commandMap.put("printwatches", "on|off");
         commandMap.put("quit", "");
+	commandMap.put("multi", "");
 
         new CloseCommand().addToMap(commandMapCli);
         new CreateCommand().addToMap(commandMapCli);
@@ -650,6 +651,22 @@ public class ZooKeeperMain {
             } else {
                 connectToZK(host);                
             }
+        } else if (cmd.equals("multi")) {
+            //CHANG: customized helper command
+            //model after testMultiTransaction
+            try {
+                //zk.create("/tnode1", "aa".getBytes(),
+                //        ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
+                Transaction transaction = zk.transaction();
+                //transaction.setData("/11", "no way".getBytes(), -1);
+                transaction.create("/44", "bb".getBytes(),
+                        ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
+                transaction.commit();
+            }
+            catch (Exception ex)
+            {
+                ex.printStackTrace();
+            }
         } 
         
         // Below commands all need a live connection
diff --git a/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
index 1dabef669..79b74fe50 100644
--- a/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
@@ -22,6 +22,7 @@ import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.List;
 
+import edu.jhu.order.t2c.dynamicd.runtime.MarkedOpFunc;
 import org.apache.jute.Record;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -82,6 +83,23 @@ public class FinalRequestProcessor implements RequestProcessor {
         this.zks = zks;
     }
 
+    @MarkedOpFunc("exists")
+    Record existsRequest(Request request,  ServerCnxn cnxn) throws IOException, KeeperException
+    {
+        // TODO we need to figure out the security requirement for this!
+        ExistsRequest existsRequest = new ExistsRequest();
+        ByteBufferInputStream.byteBuffer2Record(request.request,
+                existsRequest);
+        String path = existsRequest.getPath();
+        if (path.indexOf('\0') != -1) {
+            throw new KeeperException.BadArgumentsException();
+        }
+        Stat stat = zks.getZKDatabase().statNode(path, existsRequest
+                .getWatch() ? cnxn : null);
+        Record rsp = new ExistsResponse(stat);
+        return rsp;
+    }
+
     public void processRequest(Request request) {
         if (LOG.isDebugEnabled()) {
             LOG.debug("Processing request:: " + request);
@@ -271,17 +289,7 @@ public class FinalRequestProcessor implements RequestProcessor {
             }
             case OpCode.exists: {
                 lastOp = "EXIS";
-                // TODO we need to figure out the security requirement for this!
-                ExistsRequest existsRequest = new ExistsRequest();
-                ByteBufferInputStream.byteBuffer2Record(request.request,
-                        existsRequest);
-                String path = existsRequest.getPath();
-                if (path.indexOf('\0') != -1) {
-                    throw new KeeperException.BadArgumentsException();
-                }
-                Stat stat = zks.getZKDatabase().statNode(path, existsRequest
-                        .getWatch() ? cnxn : null);
-                rsp = new ExistsResponse(stat);
+                rsp = existsRequest(request,cnxn);
                 break;
             }
             case OpCode.getData: {
diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index 3c695be9d..2d7184873 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -36,6 +36,7 @@ import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.LinkedBlockingQueue;
 
+import edu.jhu.order.t2c.dynamicd.runtime.Operation;
 import org.apache.jute.Record;
 import org.apache.jute.BinaryOutputArchive;
 
@@ -82,6 +83,8 @@ import org.apache.zookeeper.txn.Txn;
 import org.apache.zookeeper.txn.MultiTxn;
 import org.apache.zookeeper.txn.TxnHeader;
 
+import edu.jhu.order.t2c.dynamicd.runtime.MarkedOpFunc;
+
 /**
  * This request processor is generally at the start of a RequestProcessor
  * change. It sets up any transactions associated with requests that change the
@@ -332,6 +335,347 @@ public class PrepRequestProcessor extends Thread implements RequestProcessor {
         return path.substring(0, lastSlash);
     }
 
+    @MarkedOpFunc("create")
+    void createRequest(Request request,  Record record, boolean deserialize) throws KeeperException, IOException, RequestProcessorException
+    {
+        zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
+        CreateRequest createRequest = (CreateRequest)record;
+        if (deserialize) {
+            ByteBufferInputStream.byteBuffer2Record(request.request, createRequest);
+        }
+        String path = createRequest.getPath();
+        String parentPath = validatePathForCreate(path, request.sessionId);
+
+        List<ACL> listACL = removeDuplicates(createRequest.getAcl());
+        if (!fixupACL(request.authInfo, listACL)) {
+            throw new KeeperException.InvalidACLException(path);
+        }
+        ChangeRecord parentRecord = getRecordForPath(parentPath);
+
+        checkACL(zks, parentRecord.acl, ZooDefs.Perms.CREATE, request.authInfo);
+        int parentCVersion = parentRecord.stat.getCversion();
+        CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());
+        if (createMode.isSequential()) {
+            path = path + String.format(Locale.ENGLISH, "%010d", parentCVersion);
+        }
+        try {
+            PathUtils.validatePath(path);
+        } catch(IllegalArgumentException ie) {
+            LOG.info("Invalid path " + path + " with session 0x" +
+                    Long.toHexString(request.sessionId));
+            throw new KeeperException.BadArgumentsException(path);
+        }
+        try {
+            if (getRecordForPath(path) != null) {
+                throw new KeeperException.NodeExistsException(path);
+            }
+        } catch (KeeperException.NoNodeException e) {
+            // ignore this one
+        }
+        boolean ephemeralParent = parentRecord.stat.getEphemeralOwner() != 0;
+        if (ephemeralParent) {
+            throw new KeeperException.NoChildrenForEphemeralsException(path);
+        }
+        int newCversion = parentRecord.stat.getCversion()+1;
+        request.setTxn(new CreateTxn(path, createRequest.getData(), listACL, createMode.isEphemeral(),
+                newCversion));
+        StatPersisted s = new StatPersisted();
+        if (createMode.isEphemeral()) {
+            s.setEphemeralOwner(request.sessionId);
+        }
+        parentRecord = parentRecord.duplicate(request.getHdr().getZxid());
+        parentRecord.childCount++;
+        parentRecord.stat.setCversion(newCversion);
+        addChangeRecord(parentRecord);
+        addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path, s, 0, listACL));
+    }
+
+    @MarkedOpFunc("create2")
+    void create2Request(Request request,  Record record, boolean deserialize) throws KeeperException, IOException, RequestProcessorException
+    {
+        zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
+        Create2Request createRequest = (Create2Request)record;
+        if (deserialize) {
+            ByteBufferInputStream.byteBuffer2Record(request.request, createRequest);
+        }
+        String path = createRequest.getPath();
+        String parentPath = validatePathForCreate(path, request.sessionId);
+
+        List<ACL> listACL = removeDuplicates(createRequest.getAcl());
+        if (!fixupACL(request.authInfo, listACL)) {
+            throw new KeeperException.InvalidACLException(path);
+        }
+        ChangeRecord parentRecord = getRecordForPath(parentPath);
+
+        checkACL(zks, parentRecord.acl, ZooDefs.Perms.CREATE, request.authInfo);
+        int parentCVersion = parentRecord.stat.getCversion();
+        CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());
+        if (createMode.isSequential()) {
+            path = path + String.format(Locale.ENGLISH, "%010d", parentCVersion);
+        }
+        try {
+            PathUtils.validatePath(path);
+        } catch(IllegalArgumentException ie) {
+            LOG.info("Invalid path " + path + " with session 0x" +
+                    Long.toHexString(request.sessionId));
+            throw new KeeperException.BadArgumentsException(path);
+        }
+        try {
+            if (getRecordForPath(path) != null) {
+                throw new KeeperException.NodeExistsException(path);
+            }
+        } catch (KeeperException.NoNodeException e) {
+            // ignore this one
+        }
+        boolean ephemeralParent = parentRecord.stat.getEphemeralOwner() != 0;
+        if (ephemeralParent) {
+            throw new KeeperException.NoChildrenForEphemeralsException(path);
+        }
+        int newCversion = parentRecord.stat.getCversion()+1;
+        request.setTxn(new CreateTxn(path, createRequest.getData(), listACL, createMode.isEphemeral(),
+                newCversion));
+        StatPersisted s = new StatPersisted();
+        if (createMode.isEphemeral()) {
+            s.setEphemeralOwner(request.sessionId);
+        }
+        parentRecord = parentRecord.duplicate(request.getHdr().getZxid());
+        parentRecord.childCount++;
+        parentRecord.stat.setCversion(newCversion);
+        addChangeRecord(parentRecord);
+        addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path, s, 0, listACL));
+    }
+
+    @MarkedOpFunc("delete")
+    void deleteRequest(Request request,  Record record, boolean deserialize) throws KeeperException, IOException, RequestProcessorException
+    {
+        zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
+        DeleteRequest deleteRequest = (DeleteRequest)record;
+        if(deserialize)
+            ByteBufferInputStream.byteBuffer2Record(request.request, deleteRequest);
+        String path = deleteRequest.getPath();
+        int lastSlash = path.lastIndexOf('/');
+        if (lastSlash == -1 || path.indexOf('\0') != -1
+                || zks.getZKDatabase().isSpecialPath(path)) {
+            throw new KeeperException.BadArgumentsException(path);
+        }
+        String parentPath = path.substring(0, lastSlash);
+        ChangeRecord parentRecord = getRecordForPath(parentPath);
+        ChangeRecord nodeRecord = getRecordForPath(path);
+        checkACL(zks, parentRecord.acl, ZooDefs.Perms.DELETE, request.authInfo);
+        checkAndIncVersion(nodeRecord.stat.getVersion(), deleteRequest.getVersion(), path);
+        if (nodeRecord.childCount > 0) {
+            throw new KeeperException.NotEmptyException(path);
+        }
+        request.setTxn(new DeleteTxn(path));
+        parentRecord = parentRecord.duplicate(request.getHdr().getZxid());
+        parentRecord.childCount--;
+        addChangeRecord(parentRecord);
+        addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path, null, -1, null));
+    }
+
+    @MarkedOpFunc("setData")
+    void setDataRequest(Request request,  Record record, boolean deserialize) throws KeeperException, IOException, RequestProcessorException
+    {
+        zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
+        SetDataRequest setDataRequest = (SetDataRequest)record;
+        if(deserialize)
+            ByteBufferInputStream.byteBuffer2Record(request.request, setDataRequest);
+        String path = setDataRequest.getPath();
+        ChangeRecord nodeRecord = getRecordForPath(path);
+        checkACL(zks, nodeRecord.acl, ZooDefs.Perms.WRITE, request.authInfo);
+        int newVersion = checkAndIncVersion(nodeRecord.stat.getVersion(), setDataRequest.getVersion(), path);
+        request.setTxn(new SetDataTxn(path, setDataRequest.getData(), newVersion));
+        nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());
+        nodeRecord.stat.setVersion(newVersion);
+        addChangeRecord(nodeRecord);
+    }
+
+    @MarkedOpFunc("reconfig")
+    void reconfigRequest(Request request,  Record record, boolean deserialize) throws KeeperException, IOException, RequestProcessorException
+    {
+        zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
+        ReconfigRequest reconfigRequest = (ReconfigRequest)record;                             
+        LeaderZooKeeperServer lzks = (LeaderZooKeeperServer)zks;
+        QuorumVerifier lastSeenQV = lzks.self.getLastSeenQuorumVerifier();                                                                                 
+        // check that there's no reconfig in progress
+        if (lastSeenQV.getVersion()!=lzks.self.getQuorumVerifier().getVersion()) {
+                throw new KeeperException.ReconfigInProgress(); 
+        }
+        long configId = reconfigRequest.getCurConfigId();
+
+        if (configId != -1 && configId!=lzks.self.getLastSeenQuorumVerifier().getVersion()){
+            String msg = "Reconfiguration from version " + configId + " failed -- last seen version is " + lzks.self.getLastSeenQuorumVerifier().getVersion();
+            throw new KeeperException.BadVersionException(msg);
+        }
+
+        String newMembers = reconfigRequest.getNewMembers();
+        
+        if (newMembers != null) { //non-incremental membership change                  
+            LOG.info("Non-incremental reconfig");
+        
+            // Input may be delimited by either commas or newlines so convert to common newline separated format
+            newMembers = newMembers.replaceAll(",", "\n");
+            
+            try{
+                Properties props = new Properties();                        
+                props.load(new StringReader(newMembers));
+                QuorumPeerConfig config = new QuorumPeerConfig();
+                config.parseDynamicConfig(props, lzks.self.getElectionType(), true);
+                request.qv = config.getQuorumVerifier();
+                request.qv.setVersion(request.getHdr().getZxid());
+            } catch (IOException e) {
+                throw new KeeperException.BadArgumentsException(e.getMessage());
+            } catch (ConfigException e) {
+                throw new KeeperException.BadArgumentsException(e.getMessage());
+            }                   
+        } else { //incremental change - must be a majority quorum system   
+            LOG.info("Incremental reconfig");
+            
+            List<String> joiningServers = null; 
+            String joiningServersString = reconfigRequest.getJoiningServers();
+            if (joiningServersString != null)
+            {
+                joiningServers = StringUtils.split(joiningServersString,",");
+            }
+            
+            List<String> leavingServers = null;
+            String leavingServersString = reconfigRequest.getLeavingServers();
+            if (leavingServersString != null)
+            {
+                leavingServers = StringUtils.split(leavingServersString, ",");
+            }
+            
+            if (!(lastSeenQV instanceof QuorumMaj)) {
+                    String msg = "Incremental reconfiguration requested but last configuration seen has a non-majority quorum system";
+                    LOG.warn(msg);
+                    throw new KeeperException.BadArgumentsException(msg);               
+            }
+            Map<Long, QuorumServer> nextServers = new HashMap<Long, QuorumServer>(lastSeenQV.getAllMembers());
+            try {                           
+                if (leavingServers != null) {
+                    for (String leaving: leavingServers){
+                        long sid = Long.parseLong(leaving);
+                        nextServers.remove(sid);
+                    } 
+                }
+                if (joiningServers != null) {
+                    for (String joiner: joiningServers){
+                        // joiner should have the following format: server.x = server_spec;client_spec               
+                        String[] parts = StringUtils.split(joiner, "=").toArray(new String[0]);
+                        if (parts.length != 2) {
+                            throw new KeeperException.BadArgumentsException("Wrong format of server string");
+                        }
+                        // extract server id x from first part of joiner: server.x
+                        Long sid = Long.parseLong(parts[0].substring(parts[0].lastIndexOf('.') + 1));
+                        QuorumServer qs = new QuorumServer(sid, parts[1]);
+                        if (qs.clientAddr == null || qs.electionAddr == null || qs.addr == null) {
+                            throw new KeeperException.BadArgumentsException("Wrong format of server string - each server should have 3 ports specified"); 	   
+                        }
+                        nextServers.remove(qs.id);
+                        nextServers.put(Long.valueOf(qs.id), qs);
+                    }  
+                }
+            } catch (ConfigException e){
+                throw new KeeperException.BadArgumentsException("Reconfiguration failed");
+            }
+            request.qv = new QuorumMaj(nextServers);
+            request.qv.setVersion(request.getHdr().getZxid());
+        }                             
+        if (request.qv.getVotingMembers().size() < 2){
+            String msg = "Reconfig failed - new configuration must include at least 2 followers";
+            LOG.warn(msg);
+            throw new KeeperException.BadArgumentsException(msg);
+        }
+            
+        if (!lzks.getLeader().isQuorumSynced(request.qv)) {
+            String msg2 = "Reconfig failed - there must be a connected and synced quorum in new configuration";
+            LOG.warn(msg2);             
+            throw new KeeperException.NewConfigNoQuorum();
+        }
+        
+        ChangeRecord nodeRecord = getRecordForPath(ZooDefs.CONFIG_NODE);               
+        checkACL(zks, nodeRecord.acl, ZooDefs.Perms.WRITE, request.authInfo);                  
+        request.setTxn(new SetDataTxn(ZooDefs.CONFIG_NODE, request.qv.toString().getBytes(), -1));    
+        nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());
+        nodeRecord.stat.setVersion(-1);                
+        addChangeRecord(nodeRecord);
+    }
+
+    @MarkedOpFunc("setACL")
+    void setACLRequest(Request request,  Record record, boolean deserialize) throws KeeperException, IOException, RequestProcessorException
+    {
+        zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
+        SetACLRequest setAclRequest = (SetACLRequest)record;
+        if(deserialize)
+            ByteBufferInputStream.byteBuffer2Record(request.request, setAclRequest);
+        String path = setAclRequest.getPath();
+        List<ACL> listACL = removeDuplicates(setAclRequest.getAcl());
+        if (!fixupACL(request.authInfo, listACL)) {
+            throw new KeeperException.InvalidACLException(path);
+        }
+        ChangeRecord nodeRecord = getRecordForPath(path);
+        checkACL(zks, nodeRecord.acl, ZooDefs.Perms.ADMIN, request.authInfo);
+        int newVersion = checkAndIncVersion(nodeRecord.stat.getAversion(), setAclRequest.getVersion(), path);
+        request.setTxn(new SetACLTxn(path, listACL, newVersion));
+        nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());
+        nodeRecord.stat.setAversion(newVersion);
+        addChangeRecord(nodeRecord);
+    }
+
+    @MarkedOpFunc("createSession")
+    void createSessionRequest(Request request,  Record record, boolean deserialize) throws KeeperException, IOException, RequestProcessorException
+    {
+        request.request.rewind();
+        int to = request.request.getInt();
+        request.setTxn(new CreateSessionTxn(to));
+        request.request.rewind();
+        zks.sessionTracker.addSession(request.sessionId, to);
+        zks.setOwner(request.sessionId, request.getOwner());
+    }
+
+    @MarkedOpFunc("closeSession")
+    void closeSessionRequest(Request request,  Record record, boolean deserialize) throws KeeperException, IOException, RequestProcessorException
+    {
+        // We don't want to do this check since the session expiration thread
+        // queues up this operation without being the session owner.
+        // this request is the last of the session so it should be ok
+        //zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
+        Set<String> es = zks.getZKDatabase()
+                .getEphemerals(request.sessionId);
+        synchronized (zks.outstandingChanges) {
+            for (ChangeRecord c : zks.outstandingChanges) {
+                if (c.stat == null) {
+                    // Doing a delete
+                    es.remove(c.path);
+                } else if (c.stat.getEphemeralOwner() == request.sessionId) {
+                    es.add(c.path);
+                }
+            }
+            for (String path2Delete : es) {
+                addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path2Delete, null, 0, null));
+            }
+
+            zks.sessionTracker.setSessionClosing(request.sessionId);
+        }
+
+        LOG.info("Processed session termination for sessionid: 0x"
+                + Long.toHexString(request.sessionId));
+    }
+
+    @MarkedOpFunc("check")
+    void checkRequest(Request request,  Record record, boolean deserialize) throws KeeperException, IOException, RequestProcessorException
+    {
+        zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
+        CheckVersionRequest checkVersionRequest = (CheckVersionRequest)record;
+        if(deserialize)
+            ByteBufferInputStream.byteBuffer2Record(request.request, checkVersionRequest);
+        String path = checkVersionRequest.getPath();
+        ChangeRecord nodeRecord = getRecordForPath(path);
+        checkACL(zks, nodeRecord.acl, ZooDefs.Perms.READ, request.authInfo);
+        request.setTxn(new CheckVersionTxn(path, checkAndIncVersion(nodeRecord.stat.getVersion(),
+                checkVersionRequest.getVersion(), path)));
+    }
+
     /**
      * This method will be called inside the ProcessRequestThread, which is a
      * singleton, so there will be a single thread calling this code.
@@ -349,320 +693,33 @@ public class PrepRequestProcessor extends Thread implements RequestProcessor {
 
         switch (type) {
             case OpCode.create: {
-                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
-                CreateRequest createRequest = (CreateRequest)record;
-                if (deserialize) {
-                    ByteBufferInputStream.byteBuffer2Record(request.request, createRequest);
-                }
-                String path = createRequest.getPath();
-                String parentPath = validatePathForCreate(path, request.sessionId);
-
-                List<ACL> listACL = removeDuplicates(createRequest.getAcl());
-                if (!fixupACL(request.authInfo, listACL)) {
-                    throw new KeeperException.InvalidACLException(path);
-                }
-                ChangeRecord parentRecord = getRecordForPath(parentPath);
-
-                checkACL(zks, parentRecord.acl, ZooDefs.Perms.CREATE, request.authInfo);
-                int parentCVersion = parentRecord.stat.getCversion();
-                CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());
-                if (createMode.isSequential()) {
-                    path = path + String.format(Locale.ENGLISH, "%010d", parentCVersion);
-                }
-                try {
-                    PathUtils.validatePath(path);
-                } catch(IllegalArgumentException ie) {
-                    LOG.info("Invalid path " + path + " with session 0x" +
-                            Long.toHexString(request.sessionId));
-                    throw new KeeperException.BadArgumentsException(path);
-                }
-                try {
-                    if (getRecordForPath(path) != null) {
-                        throw new KeeperException.NodeExistsException(path);
-                    }
-                } catch (KeeperException.NoNodeException e) {
-                    // ignore this one
-                }
-                boolean ephemeralParent = parentRecord.stat.getEphemeralOwner() != 0;
-                if (ephemeralParent) {
-                    throw new KeeperException.NoChildrenForEphemeralsException(path);
-                }
-                int newCversion = parentRecord.stat.getCversion()+1;
-                request.setTxn(new CreateTxn(path, createRequest.getData(), listACL, createMode.isEphemeral(),
-                        newCversion));
-                StatPersisted s = new StatPersisted();
-                if (createMode.isEphemeral()) {
-                    s.setEphemeralOwner(request.sessionId);
-                }
-                parentRecord = parentRecord.duplicate(request.getHdr().getZxid());
-                parentRecord.childCount++;
-                parentRecord.stat.setCversion(newCversion);
-                addChangeRecord(parentRecord);
-                addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path, s, 0, listACL));
+                createRequest(request, record, deserialize);
                 break;
             }
             case OpCode.create2: {
-                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
-                Create2Request createRequest = (Create2Request)record;
-                if (deserialize) {
-                    ByteBufferInputStream.byteBuffer2Record(request.request, createRequest);
-                }
-                String path = createRequest.getPath();
-                String parentPath = validatePathForCreate(path, request.sessionId);
-
-                List<ACL> listACL = removeDuplicates(createRequest.getAcl());
-                if (!fixupACL(request.authInfo, listACL)) {
-                    throw new KeeperException.InvalidACLException(path);
-                }
-                ChangeRecord parentRecord = getRecordForPath(parentPath);
-
-                checkACL(zks, parentRecord.acl, ZooDefs.Perms.CREATE, request.authInfo);
-                int parentCVersion = parentRecord.stat.getCversion();
-                CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());
-                if (createMode.isSequential()) {
-                    path = path + String.format(Locale.ENGLISH, "%010d", parentCVersion);
-                }
-                try {
-                    PathUtils.validatePath(path);
-                } catch(IllegalArgumentException ie) {
-                    LOG.info("Invalid path " + path + " with session 0x" +
-                            Long.toHexString(request.sessionId));
-                    throw new KeeperException.BadArgumentsException(path);
-                }
-                try {
-                    if (getRecordForPath(path) != null) {
-                        throw new KeeperException.NodeExistsException(path);
-                    }
-                } catch (KeeperException.NoNodeException e) {
-                    // ignore this one
-                }
-                boolean ephemeralParent = parentRecord.stat.getEphemeralOwner() != 0;
-                if (ephemeralParent) {
-                    throw new KeeperException.NoChildrenForEphemeralsException(path);
-                }
-                int newCversion = parentRecord.stat.getCversion()+1;
-                request.setTxn(new CreateTxn(path, createRequest.getData(), listACL, createMode.isEphemeral(),
-                        newCversion));
-                StatPersisted s = new StatPersisted();
-                if (createMode.isEphemeral()) {
-                    s.setEphemeralOwner(request.sessionId);
-                }
-                parentRecord = parentRecord.duplicate(request.getHdr().getZxid());
-                parentRecord.childCount++;
-                parentRecord.stat.setCversion(newCversion);
-                addChangeRecord(parentRecord);
-                addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path, s, 0, listACL));
+                create2Request(request, record, deserialize);
                 break;
             }
             case OpCode.delete:
-                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
-                DeleteRequest deleteRequest = (DeleteRequest)record;
-                if(deserialize)
-                    ByteBufferInputStream.byteBuffer2Record(request.request, deleteRequest);
-                String path = deleteRequest.getPath();
-                int lastSlash = path.lastIndexOf('/');
-                if (lastSlash == -1 || path.indexOf('\0') != -1
-                        || zks.getZKDatabase().isSpecialPath(path)) {
-                    throw new KeeperException.BadArgumentsException(path);
-                }
-                String parentPath = path.substring(0, lastSlash);
-                ChangeRecord parentRecord = getRecordForPath(parentPath);
-                ChangeRecord nodeRecord = getRecordForPath(path);
-                checkACL(zks, parentRecord.acl, ZooDefs.Perms.DELETE, request.authInfo);
-                checkAndIncVersion(nodeRecord.stat.getVersion(), deleteRequest.getVersion(), path);
-                if (nodeRecord.childCount > 0) {
-                    throw new KeeperException.NotEmptyException(path);
-                }
-                request.setTxn(new DeleteTxn(path));
-                parentRecord = parentRecord.duplicate(request.getHdr().getZxid());
-                parentRecord.childCount--;
-                addChangeRecord(parentRecord);
-                addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path, null, -1, null));
+                deleteRequest(request, record, deserialize);
                 break;
             case OpCode.setData:
-                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
-                SetDataRequest setDataRequest = (SetDataRequest)record;
-                if(deserialize)
-                    ByteBufferInputStream.byteBuffer2Record(request.request, setDataRequest);
-                path = setDataRequest.getPath();
-                nodeRecord = getRecordForPath(path);
-                checkACL(zks, nodeRecord.acl, ZooDefs.Perms.WRITE, request.authInfo);
-                int newVersion = checkAndIncVersion(nodeRecord.stat.getVersion(), setDataRequest.getVersion(), path);
-                request.setTxn(new SetDataTxn(path, setDataRequest.getData(), newVersion));
-                nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());
-                nodeRecord.stat.setVersion(newVersion);
-                addChangeRecord(nodeRecord);
+                setDataRequest(request, record, deserialize);
                 break;
             case OpCode.reconfig:
-                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
-                ReconfigRequest reconfigRequest = (ReconfigRequest)record;                             
-                LeaderZooKeeperServer lzks = (LeaderZooKeeperServer)zks;
-                QuorumVerifier lastSeenQV = lzks.self.getLastSeenQuorumVerifier();                                                                                 
-                // check that there's no reconfig in progress
-                if (lastSeenQV.getVersion()!=lzks.self.getQuorumVerifier().getVersion()) {
-                       throw new KeeperException.ReconfigInProgress(); 
-                }
-                long configId = reconfigRequest.getCurConfigId();
-  
-                if (configId != -1 && configId!=lzks.self.getLastSeenQuorumVerifier().getVersion()){
-                   String msg = "Reconfiguration from version " + configId + " failed -- last seen version is " + lzks.self.getLastSeenQuorumVerifier().getVersion();
-                   throw new KeeperException.BadVersionException(msg);
-                }
-
-                String newMembers = reconfigRequest.getNewMembers();
-                
-                if (newMembers != null) { //non-incremental membership change                  
-                   LOG.info("Non-incremental reconfig");
-                
-                   // Input may be delimited by either commas or newlines so convert to common newline separated format
-                   newMembers = newMembers.replaceAll(",", "\n");
-                   
-                   try{
-                       Properties props = new Properties();                        
-                       props.load(new StringReader(newMembers));
-                       QuorumPeerConfig config = new QuorumPeerConfig();
-                       config.parseDynamicConfig(props, lzks.self.getElectionType(), true);
-                       request.qv = config.getQuorumVerifier();
-                       request.qv.setVersion(request.getHdr().getZxid());
-                   } catch (IOException e) {
-                       throw new KeeperException.BadArgumentsException(e.getMessage());
-                   } catch (ConfigException e) {
-                       throw new KeeperException.BadArgumentsException(e.getMessage());
-                   }                   
-                } else { //incremental change - must be a majority quorum system   
-                   LOG.info("Incremental reconfig");
-                   
-                   List<String> joiningServers = null; 
-                   String joiningServersString = reconfigRequest.getJoiningServers();
-                   if (joiningServersString != null)
-                   {
-                       joiningServers = StringUtils.split(joiningServersString,",");
-                   }
-                   
-                   List<String> leavingServers = null;
-                   String leavingServersString = reconfigRequest.getLeavingServers();
-                   if (leavingServersString != null)
-                   {
-                       leavingServers = StringUtils.split(leavingServersString, ",");
-                   }
-                   
-                   if (!(lastSeenQV instanceof QuorumMaj)) {
-                           String msg = "Incremental reconfiguration requested but last configuration seen has a non-majority quorum system";
-                           LOG.warn(msg);
-                           throw new KeeperException.BadArgumentsException(msg);               
-                   }
-                   Map<Long, QuorumServer> nextServers = new HashMap<Long, QuorumServer>(lastSeenQV.getAllMembers());
-                   try {                           
-                       if (leavingServers != null) {
-                           for (String leaving: leavingServers){
-                               long sid = Long.parseLong(leaving);
-                               nextServers.remove(sid);
-                           } 
-                       }
-                       if (joiningServers != null) {
-                           for (String joiner: joiningServers){
-                        	   // joiner should have the following format: server.x = server_spec;client_spec               
-                        	   String[] parts = StringUtils.split(joiner, "=").toArray(new String[0]);
-                               if (parts.length != 2) {
-                                   throw new KeeperException.BadArgumentsException("Wrong format of server string");
-                               }
-                               // extract server id x from first part of joiner: server.x
-                               Long sid = Long.parseLong(parts[0].substring(parts[0].lastIndexOf('.') + 1));
-                               QuorumServer qs = new QuorumServer(sid, parts[1]);
-                               if (qs.clientAddr == null || qs.electionAddr == null || qs.addr == null) {
-                                   throw new KeeperException.BadArgumentsException("Wrong format of server string - each server should have 3 ports specified"); 	   
-                               }
-                               nextServers.remove(qs.id);
-                               nextServers.put(Long.valueOf(qs.id), qs);
-                           }  
-                       }
-                   } catch (ConfigException e){
-                       throw new KeeperException.BadArgumentsException("Reconfiguration failed");
-                   }
-                   request.qv = new QuorumMaj(nextServers);
-                   request.qv.setVersion(request.getHdr().getZxid());
-                }                             
-                if (request.qv.getVotingMembers().size() < 2){
-                   String msg = "Reconfig failed - new configuration must include at least 2 followers";
-                   LOG.warn(msg);
-                   throw new KeeperException.BadArgumentsException(msg);
-               }
-                   
-                if (!lzks.getLeader().isQuorumSynced(request.qv)) {
-                   String msg2 = "Reconfig failed - there must be a connected and synced quorum in new configuration";
-                   LOG.warn(msg2);             
-                   throw new KeeperException.NewConfigNoQuorum();
-                }
-                
-                nodeRecord = getRecordForPath(ZooDefs.CONFIG_NODE);               
-                checkACL(zks, nodeRecord.acl, ZooDefs.Perms.WRITE, request.authInfo);                  
-                request.setTxn(new SetDataTxn(ZooDefs.CONFIG_NODE, request.qv.toString().getBytes(), -1));    
-                nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());
-                nodeRecord.stat.setVersion(-1);                
-                addChangeRecord(nodeRecord);
+                reconfigRequest(request, record, deserialize);
                 break;                         
             case OpCode.setACL:
-                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
-                SetACLRequest setAclRequest = (SetACLRequest)record;
-                if(deserialize)
-                    ByteBufferInputStream.byteBuffer2Record(request.request, setAclRequest);
-                path = setAclRequest.getPath();
-                List<ACL> listACL = removeDuplicates(setAclRequest.getAcl());
-                if (!fixupACL(request.authInfo, listACL)) {
-                    throw new KeeperException.InvalidACLException(path);
-                }
-                nodeRecord = getRecordForPath(path);
-                checkACL(zks, nodeRecord.acl, ZooDefs.Perms.ADMIN, request.authInfo);
-                newVersion = checkAndIncVersion(nodeRecord.stat.getAversion(), setAclRequest.getVersion(), path);
-                request.setTxn(new SetACLTxn(path, listACL, newVersion));
-                nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());
-                nodeRecord.stat.setAversion(newVersion);
-                addChangeRecord(nodeRecord);
+                setACLRequest(request, record, deserialize);
                 break;
             case OpCode.createSession:
-                request.request.rewind();
-                int to = request.request.getInt();
-                request.setTxn(new CreateSessionTxn(to));
-                request.request.rewind();
-                zks.sessionTracker.addSession(request.sessionId, to);
-                zks.setOwner(request.sessionId, request.getOwner());
+                createSessionRequest(request, record, deserialize);
                 break;
             case OpCode.closeSession:
-                // We don't want to do this check since the session expiration thread
-                // queues up this operation without being the session owner.
-                // this request is the last of the session so it should be ok
-                //zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
-                Set<String> es = zks.getZKDatabase()
-                        .getEphemerals(request.sessionId);
-                synchronized (zks.outstandingChanges) {
-                    for (ChangeRecord c : zks.outstandingChanges) {
-                        if (c.stat == null) {
-                            // Doing a delete
-                            es.remove(c.path);
-                        } else if (c.stat.getEphemeralOwner() == request.sessionId) {
-                            es.add(c.path);
-                        }
-                    }
-                    for (String path2Delete : es) {
-                        addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path2Delete, null, 0, null));
-                    }
-
-                    zks.sessionTracker.setSessionClosing(request.sessionId);
-                }
-
-                LOG.info("Processed session termination for sessionid: 0x"
-                        + Long.toHexString(request.sessionId));
+                closeSessionRequest(request, record, deserialize);
                 break;
             case OpCode.check:
-                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
-                CheckVersionRequest checkVersionRequest = (CheckVersionRequest)record;
-                if(deserialize)
-                    ByteBufferInputStream.byteBuffer2Record(request.request, checkVersionRequest);
-                path = checkVersionRequest.getPath();
-                nodeRecord = getRecordForPath(path);
-                checkACL(zks, nodeRecord.acl, ZooDefs.Perms.READ, request.authInfo);
-                request.setTxn(new CheckVersionTxn(path, checkAndIncVersion(nodeRecord.stat.getVersion(),
-                        checkVersionRequest.getVersion(), path)));
+                checkRequest(request, record, deserialize);
                 break;
         }
     }
diff --git a/src/java/main/org/apache/zookeeper/server/Request.java b/src/java/main/org/apache/zookeeper/server/Request.java
index c4578c60f..622caf1b6 100644
--- a/src/java/main/org/apache/zookeeper/server/Request.java
+++ b/src/java/main/org/apache/zookeeper/server/Request.java
@@ -21,6 +21,7 @@ package org.apache.zookeeper.server;
 import java.nio.ByteBuffer;
 import java.util.List;
 
+import edu.jhu.order.t2c.dynamicd.runtime.MarkedOpSubfields;
 import org.apache.jute.Record;
 import org.apache.zookeeper.KeeperException;
 import org.apache.zookeeper.ZooDefs.OpCode;
@@ -57,10 +58,13 @@ public class Request {
         this.authInfo = null;
     }
 
+    @MarkedOpSubfields
     public final long sessionId;
 
+    @MarkedOpSubfields
     public final int cxid;
 
+    @MarkedOpSubfields
     public final int type;
 
     public final ByteBuffer request;
@@ -71,6 +75,7 @@ public class Request {
 
     private Record txn;
 
+    @MarkedOpSubfields
     public long zxid = -1;
 
     public final List<Id> authInfo;
diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
index 211701ac5..93013b0e9 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
@@ -50,6 +50,8 @@ import org.apache.zookeeper.server.util.VerifyingFileFactory;
 public class QuorumPeerConfig {
     private static final Logger LOG = LoggerFactory.getLogger(QuorumPeerConfig.class);
 
+    public static QuorumPeerConfig sharedConfig = null;
+
     protected InetSocketAddress clientPortAddress;
     protected File dataDir;
     protected File dataLogDir;
@@ -98,6 +100,9 @@ public class QuorumPeerConfig {
      * @throws ConfigException error processing configuration
      */
     public void parse(String path) throws ConfigException {
+        //CHANG: saved this config instance
+        sharedConfig = this;
+
         LOG.info("Reading configuration from: " + path);
        
         try {
diff --git a/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyRequestProcessor.java
index cb4fedb5a..9fa31c18f 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyRequestProcessor.java
@@ -82,7 +82,7 @@ public class ReadOnlyRequestProcessor extends Thread implements RequestProcessor
                 case OpCode.setData:
                 case OpCode.reconfig:
                 case OpCode.setACL:
-                case OpCode.multi:
+                //case OpCode.multi:
                 case OpCode.check:
                     ReplyHeader hdr = new ReplyHeader(request.cxid, zks.getZKDatabase()
                             .getDataTreeLastProcessedZxid(), Code.NOTREADONLY.intValue());
diff --git a/src/java/test/org/apache/zookeeper/test/ClientTest.java b/src/java/test/org/apache/zookeeper/test/ClientTest.java
index 5dd0ac9ef..a3fbaaf9e 100644
--- a/src/java/test/org/apache/zookeeper/test/ClientTest.java
+++ b/src/java/test/org/apache/zookeeper/test/ClientTest.java
@@ -56,7 +56,7 @@ public class ClientTest extends ClientBase {
     protected static final Logger LOG = LoggerFactory.getLogger(ClientTest.class);
 
     /** Verify that pings are sent, keeping the "idle" client alive */
-    @Test
+    // @Test
     public void testPing() throws Exception {
         ZooKeeper zkIdle = null;
         ZooKeeper zkWatchCreator = null;
@@ -89,14 +89,14 @@ public class ClientTest extends ClientBase {
         }
     }
 
-    @Test
+    // @Test
     public void testClientwithoutWatcherObj() throws IOException,
             InterruptedException, KeeperException
     {
         performClientTest(false);
     }
 
-    @Test
+    // @Test
     public void testClientWithWatcherObj() throws IOException,
             InterruptedException, KeeperException
     {
@@ -104,7 +104,7 @@ public class ClientTest extends ClientBase {
     }
 
     /** Exercise the testable functions, verify tostring, etc... */
-    @Test
+    // @Test
     public void testTestability() throws Exception {
         TestableZooKeeper zk = createClient();
         try {
@@ -120,7 +120,7 @@ public class ClientTest extends ClientBase {
         }
     }
 
-    @Test
+    // @Test
     public void testACLs() throws Exception {
         ZooKeeper zk = null;
         try {
@@ -190,7 +190,7 @@ public class ClientTest extends ClientBase {
      * Register multiple watchers and verify that they all get notified and
      * in the right order.
      */
-    @Test
+    // @Test
     public void testMutipleWatcherObjs()
         throws IOException, InterruptedException, KeeperException
     {
@@ -457,6 +457,9 @@ public class ClientTest extends ClientBase {
             Assert.assertEquals(1, children.size());
             Assert.assertEquals(file + "0000000000", children.get(0));
 
+            if(true)
+                return;
+
             zk.create(filepath, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);
             children = zk.getChildren(path, false);
             Assert.assertEquals(2, children.size());
@@ -486,7 +489,7 @@ public class ClientTest extends ClientBase {
     
     // Test that data provided when 
     // creating sequential nodes is stored properly
-    @Test
+    // @Test
     public void testSequentialNodeData() throws Exception {
         ZooKeeper zk= null;
         String queue_handle = "/queue";
@@ -525,7 +528,7 @@ public class ClientTest extends ClientBase {
 
     }
 
-    @Test
+    // @Test
     public void testLargeNodeData() throws Exception {
         ZooKeeper zk= null;
         String queue_handle = "/large";
@@ -553,7 +556,7 @@ public class ClientTest extends ClientBase {
     }
 
     // Test that the path string is validated
-    @Test
+    // @Test
     public void testPathValidation() throws Exception {
         ZooKeeper zk = createClient();
 
@@ -661,7 +664,7 @@ public class ClientTest extends ClientBase {
 //        }
 //    }
 
-    @Test
+    // @Test
     public void testDeleteWithChildren() throws Exception {
         ZooKeeper zk = createClient();
         zk.create("/parent", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
@@ -709,7 +712,7 @@ public class ClientTest extends ClientBase {
      *
      * @throws Throwable
      */
-    @Test
+    // @Test
     public void testClientCleanup() throws Throwable {
         OSMXBean osMbean = new OSMXBean();
         if (osMbean.getUnix() == false) {
@@ -758,7 +761,7 @@ public class ClientTest extends ClientBase {
      * @return
      * @throws Exception
      */
-    @Test
+    // @Test
     public void testNonExistingOpCode() throws Exception  {
         TestableZooKeeper zk = createClient();
 
diff --git a/src/java/test/org/apache/zookeeper/test/ReadOnlyModeTest.java b/src/java/test/org/apache/zookeeper/test/ReadOnlyModeTest.java
index c705a7bba..2e4df3a01 100644
--- a/src/java/test/org/apache/zookeeper/test/ReadOnlyModeTest.java
+++ b/src/java/test/org/apache/zookeeper/test/ReadOnlyModeTest.java
@@ -53,7 +53,7 @@ public class ReadOnlyModeTest extends ZKTestCase {
     @Before
     public void setUp() throws Exception {
         System.setProperty("readonlymode.enabled", "true");
-        qu.startQuorum();
+        qu.startAll();
     }
 
     @After
@@ -80,7 +80,7 @@ public class ReadOnlyModeTest extends ZKTestCase {
 
         watcher.reset();
         qu.shutdown(2);
-        watcher.waitForConnected(CONNECTION_TIMEOUT);
+        watcher.waitForConnected(2*CONNECTION_TIMEOUT);
 
         // read operation during r/o mode
         String remoteData = new String(zk.getData(node, false, null));
@@ -107,7 +107,7 @@ public class ReadOnlyModeTest extends ZKTestCase {
      * Ensures that upon connection to a read-only server client receives
      * ConnectedReadOnly state notification.
      */
-    @Test
+    // @Test
     public void testConnectionEvents() throws Exception {
         final List<KeeperState> states = new ArrayList<KeeperState>();
         ZooKeeper zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT,
@@ -153,7 +153,7 @@ public class ReadOnlyModeTest extends ZKTestCase {
      * then connects to a majority server. Transition should be transparent for
      * the user.
      */
-    @Test
+    // @Test
     public void testSessionEstablishment() throws Exception {
         qu.shutdown(2);
 
@@ -183,7 +183,7 @@ public class ReadOnlyModeTest extends ZKTestCase {
      * server.
      */
     @SuppressWarnings("deprecation")
-    @Test
+    // @Test
     public void testSeekForRwServer() throws Exception {
 
         // setup the logger to capture all logs
diff --git a/src/java/test/org/apache/zookeeper/test/SessionTest.java b/src/java/test/org/apache/zookeeper/test/SessionTest.java
index 8e7773876..4ed72e7c4 100644
--- a/src/java/test/org/apache/zookeeper/test/SessionTest.java
+++ b/src/java/test/org/apache/zookeeper/test/SessionTest.java
@@ -299,6 +299,44 @@ public class SessionTest extends ZKTestCase {
         zk.close();
     }
 
+    /**
+     original test added in https://github.com/OrderLab/zookeeper/commit/b37b8d6713c630901e46f0191b205061c0273133
+     minor change on args since interface changed
+     */
+    @Test
+    public void testSessionTimeoutZK450() throws Exception {
+        final int TIMEOUT = 5000;
+        DisconnectableZooKeeper zk = createClient(TIMEOUT);
+        zk.create("/stest2", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);
+        zk.disconnect();
+        Thread.sleep(TIMEOUT*2);
+        zk = createClient(TIMEOUT);
+        zk.create("/stest2", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);
+        tearDown();
+        zk.close();
+        zk.disconnect();
+        setUp();
+        zk = createClient(TIMEOUT);
+        Assert.assertTrue(zk.exists("/stest2", false) != null);
+        Thread.sleep(TIMEOUT * 2);
+        Assert.assertTrue(zk.exists("/stest2", false) == null);
+        zk.close();
+    }
+
+    /**
+     a simple version we truncate
+     */
+    @Test
+    public void testSessionTimeoutSimple() throws Exception {
+        final int TIMEOUT = 5000;
+        DisconnectableZooKeeper zk = createClient(TIMEOUT);
+        zk.create("/stestaa", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);
+        Assert.assertTrue(zk.exists("/stestaa", false) != null);
+        Thread.sleep(TIMEOUT * 2);
+        //Assert.assertTrue(zk.exists("/stestaa", false) == null);
+        zk.close();
+    }
+
     /**
      * Make sure that we cannot have two connections with the same
      * session id.
